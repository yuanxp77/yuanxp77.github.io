case 'loop': case 'unloop': loop = arg === 'loop'; break; case 'goto': if (args.length === 0) { return this.error('goto missing required passage title'); } raw = args.shift(); if (typeof raw === 'object') { passage = raw.link; } else { passage = raw; } if (!Story.has(passage)) { return this.error(`passage "${passage}" does not exist`); } break; default: return this.error(`unknown action: ${arg}`); } } try { if (volume != null) { selected.volume(volume); } if (time != null) { selected.time(time); } if (mute != null) { selected.mute(mute); } if (loop != null) { selected.loop(loop); } if (passage != null) { const nsEnded = `ended.macros.macro-${this.name}_goto`; selected .off(nsEnded) .one(nsEnded, () => { selected.off(nsEnded); Engine.play(passage); }); } switch (action) { case 'fade': selected.fade(fadeOver, fadeTo); break; case 'load': selected.load(); break; case 'pause': selected.pause(); break; case 'play': selected.playWhenAllowed(); break; case 'stop': selected.stop(); break; case 'unload': selected.unload(); break; } if (Config.debug) { this.debugView.modes({ hidden : true }); } } catch (ex) { return this.error(`error executing action: ${ex.message}`); } } }); /* <<cacheaudio track_id source_list>> */ Macro.add('cacheaudio', { handler() { if (this.args.length < 2) { const errors = []; if (this.args.length < 1) { errors.push('track ID'); } if (this.args.length < 2) { errors.push('sources'); } return this.error(`no ${errors.join(' or ')} specified`); } const id = String(this.args[0]).trim(); const oldFmtRe = /^format:\s*([\w-]+)\s*;\s*/i; try { SimpleAudio.tracks.add(id, this.args.slice(1).map(source => { if (oldFmtRe.test(source)) { if (Config.debug) { return this.error(`track ID "${id}": format specifier migration required, "format:formatId;" \u2192 "formatId|"`); } source = source.replace(oldFmtRe, '$1|'); } return source; })); } catch (ex) { return this.error(ex.message); } if (Config.debug && !SimpleAudio.tracks.get(id).hasSource()) { return this.error(`track ID "${id}": no supported audio sources found`); } if (Config.debug) { this.debugView.modes({ hidden : true }); } } }); /* <<createaudiogroup group_id>> <<track track_id>> … <</createaudiogroup>> */ Macro.add('createaudiogroup', { tags : ['track'], handler() { if (this.args.length === 0) { return this.error('no group ID specified'); } if (this.payload.length === 1) { return this.error('no tracks defined via <<track>>'); } if (Config.debug) { this.debugView .modes({ nonvoid : false, hidden : true }); } const groupId = String(this.args[0]).trim(); const trackIds = []; for (let i = 1, len = this.payload.length; i < len; ++i) { if (this.payload[i].args.length < 1) { return this.error('no track ID specified'); } trackIds.push(String(this.payload[i].args[0]).trim()); if (Config.debug) { this .createDebugView(this.payload[i].name, this.payload[i].source) .modes({ nonvoid : false, hidden : true }); } } try { SimpleAudio.groups.add(groupId, trackIds); } catch (ex) { return this.error(ex.message); } if (Config.debug) { this .createDebugView(`/${this.name}`, `<</${this.name}>>`) .modes({ nonvoid : false, hidden : true }); } } }); /* <<createplaylist list_id>> <<track track_id action_list>> … <</createplaylist>> */ Macro.add('createplaylist', { tags : ['track'], handler() { if (this.args.length === 0) { return this.error('no list ID specified'); } if (this.payload.length === 1) { return this.error('no tracks defined via <<track>>'); } const playlist = Macro.get('playlist'); if (playlist.from !== null && playlist.from !== 'createplaylist') { return this.error('a playlist has already been defined with <<setplaylist>>'); } if (Config.debug) { this.debugView .modes({ nonvoid : false, hidden : true }); } const listId = String(this.args[0]).trim(); const trackObjs = []; for (let i = 1, len = this.payload.length; i < len; ++i) { if (this.payload[i].args.length === 0) { return this.error('no track ID specified'); } const trackObj = { id : String(this.payload[i].args[0]).trim() }; const args = this.payload[i].args.slice(1); while (args.length > 0) { const arg = args.shift(); let raw; let parsed; switch (arg) { case 'copy': case 'own': trackObj.own = true; break; case 'rate': if (args.length > 0) { args.shift(); } break; case 'volume': if (args.length === 0) { return this.error('volume missing required level value'); } raw = args.shift(); parsed = Number.parseFloat(raw); if (Number.isNaN(parsed) || !Number.isFinite(parsed)) { return this.error(`cannot parse volume: ${raw}`); } trackObj.volume = parsed; break; default: return this.error(`unknown action: ${arg}`); } } trackObjs.push(trackObj); if (Config.debug) { this .createDebugView(this.payload[i].name, this.payload[i].source) .modes({ nonvoid : false, hidden : true }); } } try { SimpleAudio.lists.add(listId, trackObjs); } catch (ex) { return this.error(ex.message); } if (playlist.from === null) { playlist.from = 'createplaylist'; } if (Config.debug) { this .createDebugView(`/${this.name}`, `<</${this.name}>>`) .modes({ nonvoid : false, hidden : true }); } } }); /* <<masteraudio action_list>> */ Macro.add('masteraudio', { handler() { if (this.args.length === 0) { return this.error('no actions specified'); } const args = this.args.slice(0); let action; let mute; let muteOnHide; let volume; while (args.length > 0) { const arg = args.shift(); let raw; switch (arg) { case 'load': case 'stop': case 'unload': if (action) { return this.error(errorOnePlaybackAction(arg, action)); } action = arg; break; case 'mute': case 'unmute': mute = arg === 'mute'; break; case 'muteonhide': case 'nomuteonhide': muteOnHide = arg === 'muteonhide'; break; case 'volume': if (args.length === 0) { return this.error('volume missing required level value'); } raw = args.shift(); volume = Number.parseFloat(raw); if (Number.isNaN(volume) || !Number.isFinite(volume)) { return this.error(`cannot parse volume: ${raw}`); } break; default: return this.error(`unknown action: ${arg}`); } } try { if (mute != null) { SimpleAudio.mute(mute); } if (muteOnHide != null) { SimpleAudio.muteOnHidden(muteOnHide); } if (volume != null) { SimpleAudio.volume(volume); } switch (action) { case 'load': SimpleAudio.load(); break; case 'stop': SimpleAudio.stop(); break; case 'unload': SimpleAudio.unload(); break; } if (Config.debug) { this.debugView.modes({ hidden : true }); } } catch (ex) { return this.error(`error executing action: ${ex.message}`); } } }); /* <<playlist list_id action_list>> ← <<createplaylist>> syntax <<playlist action_list>> ← <<setplaylist>> syntax */ Macro.add('playlist', { from : null, handler() { const from = this.self.from; if (from === null) { return this.error('no playlists have been created'); } let list; let args; if (from === 'createplaylist') { if (this.args.length < 2) { const errors = []; if (this.args.length < 1) { errors.push('list ID'); } if (this.args.length < 2) { errors.push('actions'); } return this.error(`no ${errors.join(' or ')} specified`); } const id = String(this.args[0]).trim(); if (!SimpleAudio.lists.has(id)) { return this.error(`playlist "${id}" does not exist`); } list = SimpleAudio.lists.get(id); args = this.args.slice(1); } else { if (this.args.length === 0) { return this.error('no actions specified'); } list = SimpleAudio.lists.get('setplaylist'); args = this.args.slice(0); } let action; let fadeOver = 5; let fadeTo; let loop; let mute; let shuffle; let volume; while (args.length > 0) { const arg = args.shift(); let raw; switch (arg) { case 'load': case 'pause': case 'play': case 'skip': case 'stop': case 'unload': if (action) { return this.error(errorOnePlaybackAction(arg, action)); } action = arg; break; case 'fadein': if (action) { return this.error(errorOnePlaybackAction(arg, action)); } action = 'fade'; fadeTo = 1; break; case 'fadeout': if (action) { return this.error(errorOnePlaybackAction(arg, action)); } action = 'fade'; fadeTo = 0; break; case 'fadeto': if (action) { return this.error(errorOnePlaybackAction(arg, action)); } if (args.length === 0) { return this.error('fadeto missing required level value'); } action = 'fade'; raw = args.shift(); fadeTo = Number.parseFloat(raw); if (Number.isNaN(fadeTo) || !Number.isFinite(fadeTo)) { return this.error(`cannot parse fadeto: ${raw}`); } break; case 'fadeoverto': if (action) { return this.error(errorOnePlaybackAction(arg, action)); } if (args.length < 2) { const errors = []; if (args.length < 1) { errors.push('seconds'); } if (args.length < 2) { errors.push('level'); } return this.error(`fadeoverto missing required ${errors.join(' and ')} value${errors.length > 1 ? 's' : ''}`); } action = 'fade'; raw = args.shift(); fadeOver = Number.parseFloat(raw); if (Number.isNaN(fadeOver) || !Number.isFinite(fadeOver)) { return this.error(`cannot parse fadeoverto: ${raw}`); } raw = args.shift(); fadeTo = Number.parseFloat(raw); if (Number.isNaN(fadeTo) || !Number.isFinite(fadeTo)) { return this.error(`cannot parse fadeoverto: ${raw}`); } break; case 'volume': if (args.length === 0) { return this.error('volume missing required level value'); } raw = args.shift(); volume = Number.parseFloat(raw); if (Number.isNaN(volume) || !Number.isFinite(volume)) { return this.error(`cannot parse volume: ${raw}`); } break; case 'mute': case 'unmute': mute = arg === 'mute'; break; case 'loop': case 'unloop': loop = arg === 'loop'; break; case 'shuffle': case 'unshuffle': shuffle = arg === 'shuffle'; break; default: return this.error(`unknown action: ${arg}`); } } try { if (volume != null) { list.volume(volume); } if (mute != null) { list.mute(mute); } if (loop != null) { list.loop(loop); } if (shuffle != null) { list.shuffle(shuffle); } switch (action) { case 'fade': list.fade(fadeOver, fadeTo); break; case 'load': list.load(); break; case 'pause': list.pause(); break; case 'play': list.playWhenAllowed(); break; case 'skip': list.skip(); break; case 'stop': list.stop(); break; case 'unload': list.unload(); break; } if (Config.debug) { this.debugView.modes({ hidden : true }); } } catch (ex) { return this.error(`error executing action: ${ex.message}`); } } }); /* <<removeaudiogroup group_id>> */ Macro.add('removeaudiogroup', { handler() { if (this.args.length === 0) { return this.error('no group ID specified'); } const id = String(this.args[0]).trim(); if (!SimpleAudio.groups.has(id)) { return this.error(`group "${id}" does not exist`); } SimpleAudio.groups.delete(id); if (Config.debug) { this.debugView.modes({ hidden : true }); } } }); /* <<removeplaylist list_id>> */ Macro.add('removeplaylist', { handler() { if (this.args.length === 0) { return this.error('no list ID specified'); } const id = String(this.args[0]).trim(); if (!SimpleAudio.lists.has(id)) { return this.error(`playlist "${id}" does not exist`); } SimpleAudio.lists.delete(id); if (Config.debug) { this.debugView.modes({ hidden : true }); } } }); /* <<waitforaudio>> */ Macro.add('waitforaudio', { skipArgs : true, handler() { SimpleAudio.loadWithScreen(); } }); /* [DEPRECATED] <<setplaylist track_id_list>> */ Macro.add('setplaylist', { handler() { if (this.args.length === 0) { return this.error('no track ID(s) specified'); } const playlist = Macro.get('playlist'); if (playlist.from !== null && playlist.from !== 'setplaylist') { return this.error('playlists have already been defined with <<createplaylist>>'); } try { SimpleAudio.lists.add('setplaylist', this.args.slice(0)); } catch (ex) { return this.error(ex.message); } if (playlist.from === null) { playlist.from = 'setplaylist'; } if (Config.debug) { this.debugView.modes({ hidden : true }); } } }); /* [DEPRECATED] <<stopallaudio>> */ Macro.add('stopallaudio', { skipArgs : true, handler() { SimpleAudio.select(':all').stop(); if (Config.debug) { this.debugView.modes({ hidden : true }); } } }); } else { Macro.add([ 'audio', 'cacheaudio', 'createaudiogroup', 'createplaylist', 'masteraudio', 'playlist', 'removeaudiogroup', 'removeplaylist', 'waitforaudio', 'setplaylist', 'stopallaudio' ], { skipArgs : true, handler() { if (Config.debug) { this.debugView.modes({ hidden : true }); } } }); } /******************************************************************************************************************* Miscellaneous Macros. *******************************************************************************************************************/ /* <<done>> */ Macro.add('done', { skipArgs : true, tags : null, handler() { const contents = this.payload[0].contents.trim(); if (contents === '') { return; } setTimeout(this.createShadowWrapper( () => $.wiki(contents) ), Engine.minDomActionDelay); } }); /* <<goto>> */ Macro.add('goto', { handler() { if (this.args.length === 0) { return this.error('no passage specified'); } const $link = jQuery(document.createElement('button')); let passage; if (typeof this.args[0] === 'object') { passage = this.args[0].link; } else { passage = this.args[0]; } $link.append(document.createTextNode(passage)); if (!Story.has(passage)) { return this.error(`passage "${passage}" does not exist`); } if (passage != null) { $link.attr('data-passage', passage); if (Story.has(passage)) { $link.addClass('link-internal'); if (Config.addVisitedLinkClass && State.hasPlayed(passage)) { $link.addClass('link-visited'); } } else { $link.addClass('link-broken'); } } else { $link.addClass('link-internal'); } $link.addClass('macro-button') .ariaClick({ namespace: '.macros', role : 'button', one : true, }, this.createShadowWrapper(()=>Engine.play(passage))) .appendTo(this.output); /* Call `Engine.play()` asynchronously. NOTE: This does not terminate the current Wikifier call chain, though, ideally, it should. Doing so would not be trivial, however, and there's also the question of whether that behavior would be unwanted by users, who are used to the current behavior from similar macros and constructs. */ if (!Config.navigation.gotohell) Wikifier.stopWikify = 2; setTimeout(() => Engine.play(passage), Engine.minDomActionDelay); } }); /* <<repeat>> & <<stop>> */ Macro.add('repeat', { isAsync : true, tags : null, timers : new Set(), t8nRe : /^(?:transition|t8n)$/, handler() { if (this.args.length === 0) { return this.error('no time value specified'); } let delay; try { delay = Math.max(Engine.minDomActionDelay, Util.fromCssTime(this.args[0])); } catch (ex) { return this.error(ex.message); } if (Config.debug) { this.debugView.modes({ block : true }); } const transition = this.args.length > 1 && this.self.t8nRe.test(this.args[1]); const $wrapper = jQuery(document.createElement('span')) .addClass(`macro-${this.name}`) .appendTo(this.output); const macroThis = this; this.self.registerInterval(this.createShadowWrapper(() => { const frag = document.createDocumentFragment(); new Wikifier(frag, this.payload[0].contents, undefined, macroThis.passageObj); let $output = $wrapper; if (transition) { $output = jQuery(document.createElement('span')) .addClass('macro-repeat-insert macro-repeat-in') .appendTo($output); } $output.append(frag); if (transition) { setTimeout(() => $output.removeClass('macro-repeat-in'), Engine.minDomActionDelay); } }), delay); }, registerInterval(callback, delay) { if (typeof callback !== 'function') { throw new TypeError('callback parameter must be a function'); } const passage = State.passage; const turn = State.turns; const timers = this.timers; let timerId = null; timerId = setInterval(() => { if (State.passage !== passage || State.turns !== turn) { clearInterval(timerId); timers.delete(timerId); return; } let timerIdCache; /* There's no catch clause because this try/finally is here simply to ensure that proper cleanup is done in the event that an exception is thrown during the `Wikifier` call. */ try { TempState.break = null; if (TempState.hasOwnProperty('repeatTimerId')) { timerIdCache = TempState.repeatTimerId; } TempState.repeatTimerId = timerId; callback.call(this); } finally { if (typeof timerIdCache !== 'undefined') { TempState.repeatTimerId = timerIdCache; } else { delete TempState.repeatTimerId; } TempState.break = null; } }, delay); timers.add(timerId); if (!prehistory.hasOwnProperty('#repeat-timers-cleanup')) { prehistory['#repeat-timers-cleanup'] = task => { delete prehistory[task]; timers.forEach(timerId => clearInterval(timerId)); timers.clear(); }; } } }); Macro.add('stop', { skipArgs : true, handler() { if (!TempState.hasOwnProperty('repeatTimerId')) { return this.error('must only be used in conjunction with its parent macro <<repeat>>'); } const timers = Macro.get('repeat').timers; const timerId = TempState.repeatTimerId; clearInterval(timerId); timers.delete(timerId); TempState.break = 2; if (Config.debug) { this.debugView.modes({ hidden : true }); } } }); /* <<timed>> & <<next>> */ Macro.add('timed', { isAsync : true, tags : ['next'], timers : new Set(), t8nRe : /^(?:transition|t8n)$/, handler() { if (this.args.length === 0) { return this.error('no time value specified in <<timed>>'); } const items = []; try { items.push({ name : this.name, source : this.source, delay : Math.max(Engine.minDomActionDelay, Util.fromCssTime(this.args[0])), content : this.payload[0].contents }); } catch (ex) { return this.error(`${ex.message} in <<timed>>`); } if (this.payload.length > 1) { let i; try { let len; for (i = 1, len = this.payload.length; i < len; ++i) { items.push({ name : this.payload[i].name, source : this.payload[i].source, delay : this.payload[i].args.length === 0 ? items[items.length - 1].delay : Math.max(Engine.minDomActionDelay, Util.fromCssTime(this.payload[i].args[0])), content : this.payload[i].contents }); } } catch (ex) { return this.error(`${ex.message} in <<next>> (#${i})`); } } if (Config.debug) { this.debugView.modes({ block : true }); } const transition = this.args.length > 1 && this.self.t8nRe.test(this.args[1]); const $wrapper = jQuery(document.createElement('span')) .addClass(`macro-${this.name}`) .appendTo(this.output); const macroThis = this; this.self.registerTimeout(this.createShadowWrapper(item => { const frag = document.createDocumentFragment(); new Wikifier(frag, item.content, undefined, macroThis.passageObj); let $output = $wrapper; if (Config.debug && item.name === 'next') { $output = jQuery(new DebugView( $output[0], 'macro', item.name, item.source ).output); } if (transition) { $output = jQuery(document.createElement('span')) .addClass('macro-timed-insert macro-timed-in') .appendTo($output); } $output.append(frag); if (transition) { setTimeout(() => $output.removeClass('macro-timed-in'), Engine.minDomActionDelay); } }), items); }, registerTimeout(callback, items) { if (typeof callback !== 'function') { throw new TypeError('callback parameter must be a function'); } const passage = State.passage; const turn = State.turns; const timers = this.timers; let timerId = null; let nextItem = items.shift(); const worker = function () { timers.delete(timerId); if (State.passage !== passage || State.turns !== turn) { return; } const curItem = nextItem; if ((nextItem = items.shift()) != null) { timerId = setTimeout(worker, nextItem.delay); timers.add(timerId); } callback.call(this, curItem); }; timerId = setTimeout(worker, nextItem.delay); timers.add(timerId); if (!prehistory.hasOwnProperty('#timed-timers-cleanup')) { prehistory['#timed-timers-cleanup'] = task => { delete prehistory[task]; timers.forEach(timerId => clearTimeout(timerId)); timers.clear(); }; } } }); /* <<widget>> */ Macro.add('widget', { tags : null, handler() { if (this.args.length === 0) { return this.error('no widget name specified'); } if (!this.passageObj) { console.error('Macro widget passageObj cannot find passageObj'); } const widgetName = this.args[0]; const isNonVoid = this.args.length > 1 && this.args[1] === 'container'; if (Macro.has(widgetName)) { if (!Macro.get(widgetName).isWidget) { return this.error(`cannot clobber existing macro "${widgetName}"`); } Macro.delete(widgetName); } try { const macroThis = this; const widgetDef = { isWidget : true, handler : (function (widgetCode) { return function () { const shadowStore = {}; if (State.temporary.hasOwnProperty('args')) { shadowStore._args = State.temporary.args; } State.temporary.args = [...this.args]; State.temporary.args.raw = this.args.raw; State.temporary.args.full = this.args.full; this.addShadow('_args'); if (isNonVoid) { if (State.temporary.hasOwnProperty('contents')) { shadowStore._contents = State.temporary.contents; } State.temporary.contents = this.payload[0].contents; this.addShadow('_contents'); } if (State.variables.hasOwnProperty('args')) { shadowStore.$args = State.variables.args; } State.variables.args = State.temporary.args; this.addShadow('$args'); try { const resFrag = document.createDocumentFragment(); const errList = []; if ( typeof window.modSC2DataManager !== 'undefined' && window.modSC2DataManager.getWikifyTracer?.()?.beforeWidget ) { const newWidgetCode = window.modSC2DataManager.getWikifyTracer().beforeWidget( widgetCode, widgetName, macroThis.passageTitle || macroThis.passageObj.title, macroThis.passageObj ); new Wikifier(resFrag, newWidgetCode, undefined, macroThis.passageObj); } else { new Wikifier(resFrag, widgetCode, undefined, macroThis.passageObj); } if (typeof window.modSC2DataManager !== 'undefined') { window.modSC2DataManager.getWikifyTracer?.()?.afterWidget?.( widgetCode, widgetName, macroThis.passageTitle || macroThis.passageObj.title, macroThis.passageObj, resFrag ); } Array.from(resFrag.querySelectorAll('.error')).forEach(errEl => { errList.push(errEl.textContent); }); if (errList.length === 0) { this.output.appendChild(resFrag); } else { return this.error(`error${errList.length > 1 ? 's' : ''} within widget code (${errList.join('; ')})`); } } catch (ex) { return this.error(`cannot execute widget: ${ex.message}`); } finally { if (shadowStore.hasOwnProperty('_args')) { State.temporary.args = shadowStore._args; } else { delete State.temporary.args; } if (isNonVoid) { if (shadowStore.hasOwnProperty('_contents')) { State.temporary.contents = shadowStore._contents; } else { delete State.temporary.contents; } } if (shadowStore.hasOwnProperty('$args')) { State.variables.args = shadowStore.$args; } else { delete State.variables.args; } } }; })(this.payload[0].contents) }; if (isNonVoid) { widgetDef.tags = []; } Macro.add(widgetName, widgetDef); if (Config.debug) { this.debugView.modes({ hidden : true }); } } catch (ex) { return this.error(`cannot create widget macro "${widgetName}": ${ex.message}`); } } }); /* <<exit>> & <<exitAll>> */ Macro.add(['exit', 'exitAll'], { handler() { Wikifier.stopWikify = this.name === 'exit' ? 1 : 2; } }); })(); /*********************************************************************************************************************** util/gettypeof.js Copyright © 2013–2023 Thomas Michael Edwards <thomasmedwards@gmail.com>. All rights reserved. Use of this source code is governed by a BSD 2-clause "Simplified" License, which may be found in the LICENSE file. ***********************************************************************************************************************/ /* Returns the value `'null'` for `null`, the value yielded by `typeof` for primitives and functions, or the `@@toStringTag` internal property for objects. Examples: getTypeOf(42n) → 'bigint' getTypeOf(true) → 'boolean' getTypeOf(function () {}) → 'function' getTypeOf(42) → 'number' getTypeOf(null) → 'null' getTypeOf("fnord") → 'string' getTypeOf(Symbol("ZETA")) → 'symbol' getTypeOf(undefined) → 'undefined' getTypeOf(['a', 'b']) → 'Array' getTypeOf({ a : 'b' }) → 'Object' getTypeOf(new Date()) → 'Date' getTypeOf(new Map()) → 'Map' getTypeOf(new Set()) → 'Set' Etc. */ var getTypeOf = (() => { const toString = Object.prototype.toString; const slice = String.prototype.slice; function getTypeOf(O) { if (O === null) { return 'null'; } const baseType = typeof O; return baseType === 'object' ? slice.call(toString.call(O), 8, -1) : baseType; } return getTypeOf; })(); /*********************************************************************************************************************** dialog.js Copyright © 2013–2023 Thomas Michael Edwards <thomasmedwards@gmail.com>. All rights reserved. Use of this source code is governed by a BSD 2-clause "Simplified" License, which may be found in the LICENSE file. ***********************************************************************************************************************/ var Dialog = (() => { 'use strict'; const DEFAULT_TOP = 50; let $overlay = null; let $dialog = null; let $title = null; let $body = null; let lastActive = null; let observer = null; let onCloseFn = null; let scrollbarWidth = 0; /******************************************************************************* Initialization Functions. *******************************************************************************/ function init() { if (DEBUG) { console.log('[Dialog/init()]'); } if (document.getElementById('ui-dialog')) { return; } scrollbarWidth = (() => { let calcWidth; try { const inner = document.createElement('p'); inner.style.width = '100%'; inner.style.height = '200px'; const outer = document.createElement('div'); outer.style.position = 'absolute'; outer.style.left = '0'; outer.style.top = '0'; outer.style.width = '100px'; outer.style.height = '100px'; outer.style.visibility = 'hidden'; outer.style.overflow = 'hidden'; outer.appendChild(inner); document.body.appendChild(outer); const w1 = inner.offsetWidth; outer.style.overflow = 'auto'; let w2 = inner.offsetWidth; if (w1 === w2) { w2 = outer.clientWidth; } document.body.removeChild(outer); calcWidth = w1 - w2; } catch (ex) { } return calcWidth || 17; })(); const $elems = jQuery(document.createDocumentFragment()) .append( '<div id="ui-overlay" class="ui-close"></div>' + '<div id="ui-dialog" tabindex="0" role="dialog" aria-labelledby="ui-dialog-title" aria-modal="true">' + '<div id="ui-dialog-titlebar">' + '<h1 id="ui-dialog-title"></h1>' + `<button id="ui-dialog-close" class="ui-close" tabindex="0" aria-label="${L10n.get('textClose')}">\ue804</button>` + '</div>' + '<div id="ui-dialog-body"></div>' + '</div>' ); $overlay = jQuery($elems.find('#ui-overlay').get(0)); $dialog = jQuery($elems.find('#ui-dialog').get(0)); $title = jQuery($elems.find('#ui-dialog-title').get(0)); $body = jQuery($elems.find('#ui-dialog-body').get(0)); $elems.insertBefore('body>script#script-sugarcube'); } /******************************************************************************* Utility Functions. *******************************************************************************/ /* Calculate the inset values, in pixels, required to fit the dialog within the current viewport based on the size of its contents and the viewport's dimentions. */ function calcInset(top) { const $window = jQuery(window); const inset = { left : '', right : '', top : '', bottom : '' }; const minPos = 10; $dialog.css(inset); let horzSpace = $window.width() - $dialog.outerWidth(true) - 1; let vertSpace = $window.height() - $dialog.outerHeight(true) - 1; if (horzSpace <= minPos * 2 + scrollbarWidth) { vertSpace -= scrollbarWidth; } if (vertSpace <= minPos * 2 + scrollbarWidth) { horzSpace -= scrollbarWidth; } if (horzSpace <= minPos * 2) { inset.left = inset.right = minPos + 'px'; } else { inset.left = inset.right = (horzSpace / 2 >> 0) + 'px'; } if (vertSpace <= minPos * 2) { inset.top = inset.bottom = minPos + 'px'; } else { const vertPos = vertSpace / 2 >> 0; if (vertPos > top) { inset.top = top + 'px'; } else { inset.top = inset.bottom = vertPos + 'px'; } } return inset; } /* Resize handler. */ function onResize(top) { if ($dialog.css('display') === 'block') { $dialog.css(calcInset(top != null ? top : DEFAULT_TOP)); } } /******************************************************************************* API Functions. *******************************************************************************/ /* Appends the specified content sources to the dialog's body container. Returns `Dialog` for further chaining. */ function append(...args) { $body.append(...args); return Dialog; } /* Closes and resets the dialog. Returns `Dialog` for further chaining. */ function close(ev) { $body.trigger(':dialogclosing'); jQuery(document).off('.dialog-close'); if (observer) { observer.disconnect(); observer = null; } else { $body.off('.dialog-resize'); } jQuery(window) .off('.dialog-resize'); $dialog .removeClass('open') .css({ left : '', right : '', top : '', bottom : '' }); jQuery('#ui-bar,#story') .find('[tabindex=-2]') .removeAttr('aria-hidden') .attr('tabindex', 0); jQuery('body>[tabindex=-3]') .removeAttr('aria-hidden') .removeAttr('tabindex'); $overlay .removeClass('open'); jQuery(document.documentElement) .removeAttr('data-dialog'); $title .empty(); $body .empty() .removeClass(); if (lastActive) { lastActive.focus(); lastActive = null; } if (onCloseFn) { try { onCloseFn(ev); } finally { onCloseFn = null; } } $body.trigger(':dialogclose'); $body.trigger(':dialogclosed'); return Dialog; } /* Prepares the dialog for use. Returns `Dialog` for further chaining. */ function create(title, classNames) { $title .empty() .append((title != null ? String(title) : '') || '\u00A0'); $body .empty() .removeClass(); if (classNames != null) { $body.addClass(classNames); } return Dialog; } /* Empties the dialog's body container. Returns `Dialog` for further chaining. */ function empty() { $body.empty(); return Dialog; } /* Returns the dialog's body container. */ function getBody() { return $body.get(0); } /* Returns whether the dialog is open. The test may be narrowed by specifing class names. */ function isOpen(classNames) { return $dialog.hasClass('open') && (classNames ? classNames.splitOrEmpty(/\s+/).every(cn => $body.hasClass(cn)) : true); } /* Opens the dialog. Returns `Dialog` for further chaining. */ function open(options, onClose) { const { top } = Object.assign({ top : DEFAULT_TOP }, options); if (onClose != null) { const closeType = getTypeOf(onClose); if (closeType !== 'function') { throw new TypeError(`Dialog.open onClose parameter must be a function (received: ${closeType})`); } onCloseFn = onClose; } else { onCloseFn = null; } $body.trigger(':dialogopening'); if (!isOpen()) { lastActive = document.activeElement || null; } jQuery(document.documentElement).attr('data-dialog', 'open'); $overlay.addClass('open'); jQuery('body>:not(script,#store-area,tw-storydata,#ui-bar,#ui-overlay,#ui-dialog)') .attr('tabindex', -3) .attr('aria-hidden', true); jQuery('#ui-bar,#story') .find('[tabindex]:not([tabindex^=-])') .attr('tabindex', -2) .attr('aria-hidden', true); const resizeHandler = jQuery.throttle(40, () => onResize(top)); $body.imagesLoaded().always(resizeHandler); $dialog .css(calcInset(top)) .addClass('open') .focus(); jQuery(window) .off('.dialog-resize') .on('resize.dialog-resize', resizeHandler); if (Has.mutationObserver) { observer = new MutationObserver(mutations => { for (let i = 0; i < mutations.length; ++i) { if (mutations[i].type === 'childList') { $body.imagesLoaded().always(resizeHandler); resizeHandler(); break; } } }); observer.observe(getBody(), { childList : true, subtree : true }); } else { $body .off('.dialog-resize') .on( 'DOMNodeInserted.dialog-resize DOMNodeRemoved.dialog-resize', () => { $body.imagesLoaded().always(resizeHandler); resizeHandler(); } ); } jQuery(document) .off('.dialog-close') .one('click.dialog-close', '.ui-close', ev => { close(ev); }) .one('keypress.dialog-close', '.ui-close', function (ev) { if (ev.which === 13 || ev.which === 32) { jQuery(this).trigger('click'); } }); $body.trigger(':dialogopen'); $body.trigger(':dialogopened'); return Dialog; } /* Resize the dialog. */ function resize(options) { return onResize(typeof options === 'object' ? options.top : undefined); } /* Renders and appends the specified content sources to the dialog's body container. Returns `Dialog` for further chaining. */ function wiki(...args) { $body.wiki(...args); return Dialog; } /* Renders and appends the specified passage to the dialog's body container. Returns `Dialog` for further chaining. */ function wikiPassage(name) { return wiki(Story.get(name).processText()); } /******************************************************************************* Deprecated Functions. *******************************************************************************/ /* [DEPRECATED] Prepares the dialog for use. Returns the dialog's body container. */ function setup(title, classNames) { create(title, classNames); return getBody(); } /******************************************************************************* Object Exports. *******************************************************************************/ return Object.preventExtensions(Object.create(null, { append : { value : append }, body : { value : getBody }, close : { value : close }, create : { value : create }, empty : { value : empty }, init : { value : init }, isOpen : { value : isOpen }, open : { value : open }, resize : { value : resize }, wiki : { value : wiki }, wikiPassage : { value : wikiPassage }, setup : { value : setup } })); })(); /*********************************************************************************************************************** engine.js Copyright © 2013–2021 Thomas Michael Edwards <thomasmedwards@gmail.com>. All rights reserved. Use of this source code is governed by a BSD 2-clause "Simplified" License, which may be found in the LICENSE file. ***********************************************************************************************************************/ /* global Alert, Config, DebugView, Dialog, Has, LoadScreen, Save, State, Story, StyleWrapper, UI, UIBar, Util, Wikifier, postdisplay, postrender, predisplay, prehistory, prerender, setDisplayTitle */ var Engine = (() => { 'use strict'; const States = Util.toEnum({ Idle : 'idle', Playing : 'playing', Rendering : 'rendering' }); const minDomActionDelay = 40; const _initDebugViews = []; let _state = States.Idle; let _lastPlay = null; let _outlinePatch = null; let _updating = null; /******************************************************************************************************************* Engine Functions. *******************************************************************************************************************/ /* Initialize the core story elements and perform some bookkeeping. */ function engineInit() { if (DEBUG) { console.log('[Engine/engineInit()]'); } /* Remove #init-no-js & #init-lacking from #init-screen. */ jQuery('#init-no-js,#init-lacking').remove(); /* Generate the core story elements and insert them into the page before the store area. */ (() => { const $elems = jQuery(document.createDocumentFragment()); const markup = Story.has('StoryInterface') && Story.get('StoryInterface').text.trim(); if (markup) { UIBar.destroy(); jQuery(document.head).find('#style-core-display').remove(); $elems.append(markup); const $passages = $elems.find('#passages'); if ($passages.length === 0) { throw new Error('no element with ID "passages" found within "StoryInterface" special passage'); } $passages .empty() .not('[aria-live]') .attr('aria-live', 'polite') .end(); $elems.find('[data-init-passage]').each((i, el) => { if (el.id === 'passages') { throw new Error(`"StoryInterface" element <${el.nodeName.toLowerCase()} id="passages"> must not contain a "data-init-passage" content attribute`); } const passage = el.getAttribute('data-init-passage').trim(); if (el.hasAttribute('data-passage')) { throw new Error(`"StoryInterface" element <${el.nodeName.toLowerCase()} data-init-passage="${passage}"> must not contain a "data-passage" content attribute`); } if (el.firstElementChild !== null) { throw new Error(`"StoryInterface" element <${el.nodeName.toLowerCase()} data-init-passage="${passage}"> contains child elements`); } if (Story.has(passage)) { jQuery(el).empty().wiki(Story.get(passage).processText().trim()); } }); const updating = []; $elems.find('[data-passage]').each((i, el) => { if (el.id === 'passages') { throw new Error(`"StoryInterface" element <${el.nodeName.toLowerCase()} id="passages"> must not contain a "data-passage" content attribute`); } const passage = el.getAttribute('data-passage').trim(); if (el.firstElementChild !== null) { throw new Error(`"StoryInterface" element <${el.nodeName.toLowerCase()} data-passage="${passage}"> contains child elements`); } if (Story.has(passage)) { updating.push({ passage, element : el }); } }); if (updating.length > 0) { _updating = updating; } Config.ui.updateStoryElements = false; } else { $elems.append('<div id="story" role="main"><div id="passages" aria-live="polite"></div></div>'); } $elems.insertBefore('body>script#script-sugarcube'); })(); /* Generate and cache the ARIA outlines <style> element (`StyleWrapper`-wrapped) and set up the handler to manipulate the outlines. IDEA: http: */ _outlinePatch = new StyleWrapper(( () => jQuery(document.createElement('style')) .attr({ id : 'style-aria-outlines', type : 'text/css' }) .appendTo(document.head) .get(0) )()); _hideOutlines(); let _lastOutlineEvent; jQuery(document).on( 'mousedown.aria-outlines keydown.aria-outlines', ev => { if (ev.type !== _lastOutlineEvent) { _lastOutlineEvent = ev.type; if (ev.type === 'keydown') { _showOutlines(); } else { _hideOutlines(); } } } ); } /* Starts the story. */ function engineStart() { if (DEBUG) { console.log('[Engine/engineStart()]'); } /* Execute `init`-tagged special passages. */ Story.getAllInit().forEach(passage => { try { console.log('engineStart() Story.getAllInit().forEach'); const debugBuffer = Wikifier.wikifyEval(passage.text, passage); if (Config.debug) { const debugView = new DebugView( document.createDocumentFragment(), 'special', `${passage.title} [init-tagged]`, `${passage.title} [init-tagged]` ); debugView.modes({ hidden : true }); debugView.append(debugBuffer); _initDebugViews.push(debugView.output); } } catch (ex) { console.error(ex); Alert.error(`${passage.title} [init-tagged]`, typeof ex === 'object' ? ex.message : ex); } }); /* Execute the StoryInit special passage. */ if (Story.has('StoryInit')) { try { console.log('engineStart() Story Execute the StoryInit special passage.'); const debugBuffer = Wikifier.wikifyEval(Story.get('StoryInit').text, Story.get('StoryInit')); if (Config.debug) { const debugView = new DebugView( document.createDocumentFragment(), 'special', 'StoryInit', 'StoryInit' ); debugView.modes({ hidden : true }); debugView.append(debugBuffer); _initDebugViews.push(debugView.output); } new Promise((resolve, reject) => { jQuery(document.createElement('script')) .one('load abort error', ev => { jQuery(ev.target).off(); if (ev.type === 'load') { resolve(ev.target); } else { reject(new Error('importScripts failed to load the script "usettings.js".')); } }) .appendTo(document.head) .attr({ id : 'script-imported-usettings.js', type : 'text/javascript', src : 'usettings.js' }); }) .then(() => console.log('usettings.js is active')) .catch(() => console.log('usettings.js not active, this is normal')); } catch (ex) { console.error(ex); Alert.error('StoryInit', typeof ex === 'object' ? ex.message : ex); } } if (Config.passages.start == null) { throw new Error('starting passage not selected'); } if (!Story.has(Config.passages.start)) { throw new Error(`starting passage ("${Config.passages.start}") not found`); } jQuery(document.documentElement).focus(); /* Attempt to restore an active session. Failing that, attempt to autoload the autosave, if requested. Failing that, display the starting passage. */ if (State.restore()) { engineShow(); } else { let loadStart = true; switch (typeof Config.saves.autoload) { case 'boolean': if (Config.saves.autoload && Save.autosave.ok() && Save.autosave.has()) { if (DEBUG) { console.log(`\tattempting autoload: "${Save.autosave.get().title}"`); } loadStart = !Save.autosave.load(); } break; case 'string': if (Config.saves.autoload === 'prompt' && Save.autosave.ok() && Save.autosave.has()) { loadStart = false; UI.buildAutoload(); Dialog.open(); } break; case 'function': if (Save.autosave.ok() && Save.autosave.has() && !!Config.saves.autoload()) { if (DEBUG) { console.log(`\tattempting autoload: "${Save.autosave.get().title}"`); } loadStart = !Save.autosave.load(); } break; } if (loadStart) { if (DEBUG) { console.log(`\tstarting passage: "${Config.passages.start}"`); } enginePlay(Config.passages.start); } } } /* Restarts the story. */ function engineRestart() { if (DEBUG) { console.log('[Engine/engineRestart()]'); } /* Show the loading screen to hide any unsightly rendering shenanigans during the page reload. */ LoadScreen.show(); /* Scroll the window to the top. This is required by most browsers for the starting passage or it will remain at whatever its current scroll position is after the page reload. We do it generally, rather than only for the currently set starting passage, since the starting passage may be dynamically manipulated. */ window.scroll(0, 0); /* Delete the active session. */ State.reset(); /* Trigger an ':enginerestart' event. */ jQuery.event.trigger(':enginerestart'); /* Reload the page. */ window.location.reload(); } /* Returns the current state of the engine. */ function engineState() { return _state; } /* Returns whether the engine is idle. */ function engineIsIdle() { return _state === States.Idle; } /* Returns whether the engine is playing. */ function engineIsPlaying() { return _state !== States.Idle; } /* Returns whether the engine is rendering. */ function engineIsRendering() { return _state === States.Rendering; } /* Returns a timestamp representing the last time `Engine.play()` was called. */ function engineLastPlay() { return _lastPlay; } /* Activate the moment at the given index within the state history and show it. */ function engineGoTo(idx) { const succeded = State.goTo(idx); if (succeded) { engineShow(); } return succeded; } /* Activate the moment at the given offset from the active moment within the state history and show it. */ function engineGo(offset) { const succeded = State.go(offset); jQuery.event.trigger({ type : ':enginego', offset, succeded }); if (succeded) { engineShow(); } return succeded; } /* Go to the moment which directly precedes the active moment and show it. */ function engineBackward() { return engineGo(-1); } /* Go to the moment which directly follows the active moment and show it. */ function engineForward() { return engineGo(1); } /* Renders and displays the active (present) moment's associated passage without adding a new moment to the history. */ function engineShow() { return enginePlay(State.passage, true); } /* Renders and displays the passage referenced by the given title, optionally without adding a new moment to the history. */ function enginePlay(title, noHistory) { if (DEBUG) { console.log(`[Engine/enginePlay(title: "${title}", noHistory: ${noHistory})]`); } let passageTitle = title; _state = States.Playing; TempState = {}; State.clearTemporary(); let passageReadyOutput; let passageDoneOutput; if (typeof Config.navigation.override === 'function') { try { const overrideTitle = Config.navigation.override(passageTitle); if (overrideTitle) { passageTitle = overrideTitle; } } catch (ex) { } } const passage = Story.get(passageTitle); jQuery.event.trigger({ type : ':passageinit', passage }); Object.keys(prehistory).forEach(task => { if (typeof prehistory[task] === 'function') { prehistory[task].call(passage, task); } }); if (!noHistory) { State.create(passage.title); } if (document.body.className) { document.body.className = ''; } _lastPlay = Util.now(); Object.keys(predisplay).forEach(task => { if (typeof predisplay[task] === 'function') { predisplay[task].call(passage, task); } }); if (Story.has('PassageReady')) { try { passageReadyOutput = Wikifier.wikifyEval(Story.get('PassageReady').text, Story.get('PassageReady')); } catch (ex) { console.error(ex); Alert.error('PassageReady', ex.message); } } _state = States.Rendering; const dataTags = passage.tags.length > 0 ? passage.tags.join(' ') : null; const passageEl = document.createElement('div'); jQuery(passageEl) .attr({ id : passage.domId, 'data-passage' : passage.title, 'data-tags' : dataTags }) .addClass(`passage ${passage.className}`); jQuery(document.body) .attr('data-tags', dataTags) .addClass(passage.className); jQuery(document.documentElement) .attr('data-tags', dataTags); jQuery.event.trigger({ type : ':passagestart', content : passageEl, passage }); Object.keys(prerender).forEach(task => { if (typeof prerender[task] === 'function') { prerender[task].call(passage, passageEl, task); } }); if (Story.has('PassageHeader')) { new Wikifier(passageEl, Story.get('PassageHeader').processText(), undefined, Story.get('PassageHeader')); } passageEl.appendChild(passage.render()); if (Story.has('PassageFooter')) { new Wikifier(passageEl, Story.get('PassageFooter').processText(), undefined, Story.get('PassageHeader')); } jQuery.event.trigger({ type : ':passagerender', content : passageEl, passage }); Object.keys(postrender).forEach(task => { if (typeof postrender[task] === 'function') { postrender[task].call(passage, passageEl, task); } }); const containerEl = document.getElementById('passages'); if (containerEl.hasChildNodes()) { if ( typeof Config.passages.transitionOut === 'number' || typeof Config.passages.transitionOut === 'string' && Config.passages.transitionOut !== '' && Has.transitionEndEvent ) { [...containerEl.childNodes].forEach(outgoing => { const $outgoing = jQuery(outgoing); if (outgoing.nodeType === Node.ELEMENT_NODE && $outgoing.hasClass('passage')) { if ($outgoing.hasClass('passage-out')) { return; } $outgoing .attr({ id : `out-${$outgoing.attr('id')}`, 'aria-live' : 'off' }) .addClass('passage-out'); if (typeof Config.passages.transitionOut === 'string') { $outgoing.on(Has.transitionEndEvent, ev => { if (ev.propertyName === Config.passages.transitionOut) { $outgoing.remove(); } }); } else { setTimeout( () => $outgoing.remove(), Math.max(minDomActionDelay, Config.passages.transitionOut) ); } } else { $outgoing.remove(); } }); } else { jQuery(containerEl).empty(); } } jQuery(passageEl) .addClass('passage-in') .appendTo(containerEl); setTimeout(() => jQuery(passageEl).removeClass('passage-in'), minDomActionDelay); if (Story.has('StoryDisplayTitle')) { if (_updating !== null || !Config.ui.updateStoryElements) { setDisplayTitle(Story.get('StoryDisplayTitle').processText()); } } else if (Config.passages.displayTitles && passage.title !== Config.passages.start) { document.title = `${passage.title} | ${Story.title}`; } window.scroll(0, 0); _state = States.Playing; if (Story.has('PassageDone')) { try { passageDoneOutput = Wikifier.wikifyEval(Story.get('PassageDone').text, Story.get('PassageDone')); } catch (ex) { console.error(ex); Alert.error('PassageDone', ex.message); } } jQuery.event.trigger({ type : ':passagedisplay', content : passageEl, passage }); Object.keys(postdisplay).forEach(task => { if (typeof postdisplay[task] === 'function') { postdisplay[task].call(passage, task); } }); if (_updating !== null) { _updating.forEach(pair => { jQuery(pair.element).empty(); new Wikifier(pair.element, Story.get(pair.passage).processText().trim(), undefined, pair.passage); }); } else if (Config.ui.updateStoryElements) { UIBar.update(); } if (Config.debug) { let debugView; if (passageReadyOutput != null) { debugView = new DebugView( document.createDocumentFragment(), 'special', 'PassageReady', 'PassageReady' ); debugView.modes({ hidden : true }); debugView.append(passageReadyOutput); jQuery(passageEl).prepend(debugView.output); } if (passageDoneOutput != null) { debugView = new DebugView( document.createDocumentFragment(), 'special', 'PassageDone', 'PassageDone' ); debugView.modes({ hidden : true }); debugView.append(passageDoneOutput); jQuery(passageEl).append(debugView.output); } if (State.turns === 1 && _initDebugViews.length > 0) { jQuery(passageEl).prepend(_initDebugViews); } } jQuery('#story') .find('a[href]:not(.link-external)') .addClass('link-external') .end() .find('a,link,button,input,select,textarea') .not('[tabindex]') .attr('tabindex', 0); switch (typeof Config.saves.autosave) { case 'boolean': if (Config.saves.autosave) { Save.autosave.save(); } break; case 'object': if (passage.tags.some(tag => Config.saves.autosave.includes(tag))) { Save.autosave.save(); } break; case 'function': if (Config.saves.autosave()) { Save.autosave.save(); } break; } jQuery.event.trigger({ type : ':passageend', content : passageEl, passage }); _state = States.Idle; _lastPlay = Util.now(); return passageEl; } /******************************************************************************************************************* Legacy Functions. *******************************************************************************************************************/ /* [DEPRECATED] Play the given passage, optionally without altering the history. */ function engineDisplay(title, link, option) { if (DEBUG) { console.log('[Engine/engineDisplay()]'); } let noHistory = false; switch (option) { case undefined: break; case 'replace': case 'back': noHistory = true; break; default: throw new Error(`Engine.display option parameter called with obsolete value "${option}"; please notify the developer`); } enginePlay(title, noHistory); } /******************************************************************************************************************* Utility Functions. *******************************************************************************************************************/ function _hideOutlines() { _outlinePatch.set('*:focus{outline:none;}'); } function _showOutlines() { _outlinePatch.clear(); } /******************************************************************************************************************* Module Exports. *******************************************************************************************************************/ return Object.freeze(Object.defineProperties({}, { /* Constants. */ States : { value : States }, minDomActionDelay : { value : minDomActionDelay }, /* Core Functions. */ init : { value : engineInit }, start : { value : engineStart }, restart : { value : engineRestart }, state : { get : engineState }, isIdle : { value : engineIsIdle }, isPlaying : { value : engineIsPlaying }, isRendering : { value : engineIsRendering }, lastPlay : { get : engineLastPlay }, goTo : { value : engineGoTo }, go : { value : engineGo }, backward : { value : engineBackward }, forward : { value : engineForward }, show : { value : engineShow }, play : { value : enginePlay }, /* Legacy Functions. */ display : { value : engineDisplay } })); })(); /*********************************************************************************************************************** passage.js Copyright © 2013–2021 Thomas Michael Edwards <thomasmedwards@gmail.com>. All rights reserved. Use of this source code is governed by a BSD 2-clause "Simplified" License, which may be found in the LICENSE file. ***********************************************************************************************************************/ var Passage = (() => { 'use strict'; let _tagsToSkip; let _twine1Unescape; /* Tags which should not be transformed into classes: debug → special tag nobr → special tag passage → the default class script → special tag (only in Twine 1) stylesheet → special tag (only in Twine 1) twine.* → special tag widget → special tag */ if (TWINE1) { _tagsToSkip = /^(?:debug|nobr|passage|script|stylesheet|widget|twine\..*)$/i; } else { _tagsToSkip = /^(?:debug|nobr|passage|widget|twine\..*)$/i; } if (TWINE1) { /* Returns a decoded version of the passed Twine 1 passage store encoded string. */ const _twine1EscapesRe = /(?:\\n|\\t|\\s|\\|\r)/g; const _hasTwine1EscapesRe = new RegExp(_twine1EscapesRe.source); const _twine1EscapesMap = Object.freeze({ '\\n' : '\n', '\\t' : '\t', '\\s' : '\\', '\\' : '\\', '\r' : '' }); _twine1Unescape = function (str) { if (str == null) { return ''; } const val = String(str); return val && _hasTwine1EscapesRe.test(val) ? val.replace(_twine1EscapesRe, esc => _twine1EscapesMap[esc]) : val; }; } /******************************************************************************************************************* Passage Class. *******************************************************************************************************************/ class Passage { constructor(title, el) { Object.defineProperties(this, { title : { value : Util.unescape(title) }, element : { value : el || null }, tags : { value : Object.freeze( el && el.hasAttribute('tags') ? Array.from(new Set(el.getAttribute('tags').trim().splitOrEmpty(/\s+/))) : [] ) }, _excerpt : { writable : true, value : null } }); Object.defineProperties(this, { domId : { value : `passage-${Util.slugify(this.title)}` }, classes : { value : Object.freeze(this.tags.length === 0 ? [] : (() => /* Return the sorted list of unique classes. NOTE: The `this.tags` array is already sorted and unique, so we only need to filter and map here. */ this.tags .filter(tag => !_tagsToSkip.test(tag)) .map(tag => Util.slugify(tag)) )()) } }); } get className() { return this.classes.join(' '); } get text() { if (this.element == null) { const passage = Util.escapeMarkup(this.title); const mesg = `${L10n.get('errorTitle')}: ${L10n.get('errorNonexistentPassage', { passage })}`; return `<div class="error-view"><span class="error">${mesg}</span></div>`; } if (TWINE1) { return _twine1Unescape(this.element.textContent); } else { return this.element.textContent.replace(/\r/g, ''); } } description() { const descriptions = Config.passages.descriptions; switch (typeof descriptions) { case 'boolean': if (descriptions) { return this.title; } break; case 'object': if (descriptions.hasOwnProperty(this.title)) { return descriptions[this.title]; } break; case 'function': { const result = descriptions.call(this); if (result) { return result; } } break; } if (this._excerpt === null) { this._excerpt = Passage.getExcerptFromText(this.text); } return this._excerpt; } processText() { if (this.element == null) { return this.text; } if (this.tags.includes('Twine.image')) { return `[img[${this.text}]]`; } let processed = this.text; if (Config.passages.onProcess) { processed = Config.passages.onProcess.call(null, { title : this.title, tags : this.tags, text : processed }); } if (Config.passages.nobr || this.tags.includes('nobr')) { processed = processed.replace(/^\n+|\n+$/g, '').replace(/\n+/g, ' '); } Wikifier.stopWikify = 0; return processed; } render(options) { const frag = document.createDocumentFragment(); new Wikifier(frag, this.processText(), options, this); this._excerpt = Passage.getExcerptFromNode(frag); return frag; } static getExcerptFromNode(node, count) { if (DEBUG) { console.log(`[Passage.getExcerptFromNode(node=…, count=${count})]`, node); } if (!node.hasChildNodes()) { return ''; } let excerpt = node.textContent.trim(); if (excerpt !== '') { const excerptRe = new RegExp(`(\\S+(?:\\s+\\S+){0,${count > 0 ? count - 1 : 7}})`); excerpt = excerpt .replace(/\s+/g, ' ') .match(excerptRe); } return excerpt ? `${excerpt[1]}\u2026` : '\u2026'; } static getExcerptFromText(text, count) { if (DEBUG) { console.log(`[Passage.getExcerptFromText(text=…, count=${count})]`, text); } if (text === '') { return ''; } const excerptRe = new RegExp(`(\\S+(?:\\s+\\S+){0,${count > 0 ? count - 1 : 7}})`); const excerpt = text .replace(/<<.*?>>/g, ' ') .replace(/<.*?>/g, ' ') .trim() .replace(/^\s*\|.*\|.*?$/gm, '') .replace(/\[[<>]?img\[[^\]]*\]\]/g, '') .replace(/\[\[([^|\]]*?)(?:(?:\||->|<-)[^\]]*)?\]\]/g, '$1') .replace(/^\s*!+(.*?)$/gm, '$1') .replace(/'{2}|\/{2}|_{2}|@{2}/g, '') .trim() .replace(/\s+/g, ' ') .match(excerptRe); return excerpt ? `${excerpt[1]}\u2026` : '\u2026'; } } /******************************************************************************************************************* Module Exports. *******************************************************************************************************************/ return Passage; })(); /*********************************************************************************************************************** save.js Copyright © 2013–2021 Thomas Michael Edwards <thomasmedwards@gmail.com>. All rights reserved. Use of this source code is governed by a BSD 2-clause "Simplified" License, which may be found in the LICENSE file. ***********************************************************************************************************************/ var Save = (() => { 'use strict'; const Type = Util.toEnum({ Autosave : 'autosave', Disk : 'disk', Serialize : 'serialize', Slot : 'slot' }); let _slotsUBound = -1; let _meta = {}; const _onLoadHandlers = new Set(); const _onSaveHandlers = new Set(); /******************************** split save stuff ********************************/ let useSplit = () => Story.domId === 'free-cities'; function indexGet() { return storage.get('index') ?? savesObjCreate(); } function splitSave(slot, data) { storage.set(slot === 'autosave' ? slot : `slot${slot}`, data); const index = indexGet(); delete data.state; slot === 'autosave' ? index.autosave = data : index.slots[slot] = data; try { storage.set('index', index); } catch (ex) { storage.delete(slot === 'autosave' ? 'autosave' : `slot${slot}`); alert('Storage quota exceeded, try removing other saves first'); } return true; } function splitDelete(slot) { storage.delete(slot === 'autosave' ? slot : `slot${slot}`); const index = indexGet(); slot === 'autosave' ? index.autosave = null : index.slots[slot] = null; storage.set('index', index); return true; } /******************************************************************************************************************* Saves Functions. *******************************************************************************************************************/ function savesInit() { if (DEBUG) { console.log('[Save/savesInit()]'); } if (storage.name === 'cookie') { savesObjClear(); Config.saves.autoload = undefined; Config.saves.autosave = undefined; Config.saves.slots = 0; return false; } let saves = savesObjGet(); let updated = false; if (Config.saves.slots !== saves.slots.length) { if (Config.saves.slots < saves.slots.length) { saves.slots.reverse(); saves.slots = saves.slots.filter(function (val) { if (val === null && this.count > 0) { --this.count; return false; } return true; }, { count : saves.slots.length - Config.saves.slots }); saves.slots.reverse(); } else if (Config.saves.slots > saves.slots.length) { _appendSlots(saves.slots, Config.saves.slots - saves.slots.length); } updated = true; } if (updated) { _savesObjSave(saves); } _slotsUBound = saves.slots.length - 1; return true; } function savesObjCreate() { return { autosave : null, slots : _appendSlots([], Config.saves.slots) }; } function savesObjGet() { const saves = storage.get(useSplit() ? 'index' : 'saves'); return saves === null ? savesObjCreate() : saves; } function savesObjClear() { storage.delete('saves'); if (useSplit()) { storage.delete('index'); storage.delete('autosave'); for (let i = 0; i < Config.save.slots - 1; i++) storage.delete(`slot${i}`); } return true; } function savesOk() { return autosaveOk() || slotsOk(); } /******************************************************************************************************************* Autosave Functions. *******************************************************************************************************************/ function autosaveOk() { return storage.name !== 'cookie' && typeof Config.saves.autosave !== 'undefined'; } function autosaveHas() { const saves = useSplit() ? { autosave : storage.get('autosave') } : savesObjGet(); if (saves.autosave === null) { return false; } return true; } function autosaveGet() { const saves = useSplit() ? { autosave : storage.get('autosave') } : savesObjGet(); return saves.autosave; } function autosaveLoad() { if (idb.active) { idb.loadState(0); return true; } const saves = useSplit() ? { autosave : storage.get('autosave') } : savesObjGet(); if (saves.autosave === null) { return false; } return _unmarshal(saves.autosave); } function autosaveSave(title, metadata) { if (typeof Config.saves.isAllowed === 'function' && !Config.saves.isAllowed()) { return false; } if (idb.active) { idb.saveState(0, title, metadata); return true; } const saves = savesObjGet(); const supplemental = { title : title || Story.get(State.passage).description(), date : Date.now() }; if (metadata != null) { supplemental.metadata = metadata; } const saveData = _marshal(supplemental, { type : Type.Autosave }); if (useSplit()) return splitSave('autosave', saveData); saves.autosave = saveData; return _savesObjSave(saves); } function autosaveDelete() { if (useSplit()) return splitDelete('autosave'); const saves = savesObjGet(); saves.autosave = null; return _savesObjSave(saves); } /******************************************************************************************************************* Slots Functions. *******************************************************************************************************************/ function slotsOk() { return storage.name !== 'cookie' && _slotsUBound !== -1; } function slotsLength() { return _slotsUBound + 1; } function slotsCount() { if (!slotsOk()) { return 0; } const saves = savesObjGet(); let count = 0; for (let i = 0, iend = saves.slots.length; i < iend; ++i) { if (saves.slots[i] !== null) { ++count; } } return count; } function slotsIsEmpty() { return slotsCount() === 0; } function slotsHas(slot) { if (slot < 0 || slot > _slotsUBound) { return false; } const saves = savesObjGet(); if (slot >= saves.slots.length || saves.slots[slot] === null) { return false; } return true; } function slotsGet(slot) { if (slot < 0 || slot > _slotsUBound) { return null; } const saves = savesObjGet(); if (slot >= saves.slots.length) { return null; } return useSplit() ? storage.get(`slot${slot}`) : saves.slots[slot]; } function slotsLoad(slot) { if (slot < 0 || slot > _slotsUBound) { return false; } const saves = savesObjGet(); if (slot >= saves.slots.length || saves.slots[slot] === null) { return false; } return _unmarshal(useSplit() ? storage.get(`slot${slot}`) : saves.slots[slot]); } function slotsSave(slot, title, metadata) { if (typeof Config.saves.isAllowed === 'function' && !Config.saves.isAllowed()) { if (Dialog.isOpen()) { $(document).one(':dialogclosed', () => UI.alert(L10n.get('savesDisallowed'))); } else { UI.alert(L10n.get('savesDisallowed')); } return false; } if (slot < 0 || slot > _slotsUBound) { return false; } const saves = savesObjGet(); if (slot >= saves.slots.length) { return false; } const supplemental = { title : title || Story.get(State.passage).description(), date : Date.now() }; if (metadata != null) { supplemental.metadata = metadata; } const saveData = _marshal(supplemental, { type : Type.Slot }); if (useSplit()) return splitSave(slot, saveData); saves.slots[slot] = saveData; return _savesObjSave(saves); } function slotsDelete(slot) { if (slot < 0 || slot > _slotsUBound) { return false; } const saves = savesObjGet(); if (slot >= saves.slots.length) { return false; } if (useSplit()) return splitDelete(slot); saves.slots[slot] = null; return _savesObjSave(saves); } /******************************************************************************************************************* Disk Import/Export Functions. *******************************************************************************************************************/ function exportToDisk(filename, metadata) { if (typeof Config.saves.isAllowed === 'function' && !Config.saves.isAllowed()) { if (Dialog.isOpen()) { $(document).one(':dialogclosed', () => UI.alert(L10n.get('savesDisallowed'))); } else { UI.alert(L10n.get('savesDisallowed')); } return; } function getDatestamp() { const now = new Date(); let MM = now.getMonth() + 1; let DD = now.getDate(); let hh = now.getHours(); let mm = now.getMinutes(); let ss = now.getSeconds(); if (MM < 10) { MM = `0${MM}`; } if (DD < 10) { DD = `0${DD}`; } if (hh < 10) { hh = `0${hh}`; } if (mm < 10) { mm = `0${mm}`; } if (ss < 10) { ss = `0${ss}`; } return `${now.getFullYear()}${MM}${DD}-${hh}${mm}${ss}`; } function getFilename(str) { return Util.sanitizeFilename(str) .replace(/[_\s\u2013\u2014-]+/g, '-'); } const baseName = filename == null ? Story.domId : getFilename(filename); const saveName = `${baseName}-${getDatestamp()}.save`; const supplemental = metadata == null ? {} : { metadata }; const data = LZString.compressToBase64(JSON.stringify(_marshal(supplemental, { type : Type.Disk }))); const saveObj = data + LZString.compressToBase64(JSON.stringify({ [Story.domId] : data.length })); saveAs(new Blob([saveObj], { type : 'text/plain;charset=UTF-8' }), saveName); } function importFromDisk(event) { const file = event.target.files[0]; const reader = new FileReader(); jQuery(reader).one('loadend', () => { if (reader.error) { const ex = reader.error; UI.alert(`${L10n.get('errorSaveDiskLoadFailed').toUpperFirst()} (${ex.name}: ${ex.message}).</p><p>${L10n.get('aborting')}.`); return; } deserialize(reader.result); }); reader.readAsText(file); } /******************************************************************************************************************* Serialization Functions. *******************************************************************************************************************/ function serialize(metadata) { if (typeof Config.saves.isAllowed === 'function' && !Config.saves.isAllowed()) { if (Dialog.isOpen()) { $(document).one(':dialogclosed', () => UI.alert(L10n.get('savesDisallowed'))); } else { UI.alert(L10n.get('savesDisallowed')); } return null; } const supplemental = metadata == null ? {} : { metadata }; supplemental.idx = State.qc; const data = LZString.compressToBase64(JSON.stringify(_marshal(supplemental, { type : Type.Serialize }))); return data + LZString.compressToBase64(JSON.stringify({ [Story.domId] : data.length })); } function deserialize(base64Str) { /* NOTE: We purposefully do not attempt to catch parameter shenanigans here, instead relying on `_unmarshal()` to do the heavy lifting. */ let saveObj; try { const jsonstring = LZString.decompressFromBase64(base64Str); const offset = LZString.compressToBase64(jsonstring).length; const metadata = JSON.parse(LZString.decompressFromBase64(base64Str.slice(offset))); _meta = metadata; saveObj = JSON.parse(jsonstring); if (_meta?.[Story.domId] !== offset) saveObj.idx += ''; } catch (ex) { } if (!_unmarshal(saveObj, 'file')) { return null; } return saveObj.metadata; } /******************************************************************************************************************* Event Functions. *******************************************************************************************************************/ function onLoadAdd(handler) { const valueType = Util.getType(handler); if (valueType !== 'function') { throw new TypeError(`Save.onLoad.add handler parameter must be a function (received: ${valueType})`); } _onLoadHandlers.add(handler); } function onLoadClear() { _onLoadHandlers.clear(); } function onLoadDelete(handler) { return _onLoadHandlers.delete(handler); } function onLoadSize() { return _onLoadHandlers.size; } function onSaveAdd(handler) { const valueType = Util.getType(handler); if (valueType !== 'function') { throw new TypeError(`Save.onSave.add handler parameter must be a function (received: ${valueType})`); } _onSaveHandlers.add(handler); } function onSaveClear() { _onSaveHandlers.clear(); } function onSaveDelete(handler) { return _onSaveHandlers.delete(handler); } function onSaveSize() { return _onSaveHandlers.size; } /******************************************************************************************************************* Utility Functions. *******************************************************************************************************************/ function _appendSlots(array, num) { for (let i = 0; i < num; ++i) { array.push(null); } return array; } function _savesObjIsEmpty(saves) { const slots = saves.slots; let isSlotsEmpty = true; for (let i = 0, iend = slots.length; i < iend; ++i) { if (slots[i] !== null) { isSlotsEmpty = false; break; } } return saves.autosave === null && isSlotsEmpty; } function _savesObjSave(saves) { if (_savesObjIsEmpty(saves)) { storage.delete('saves'); return true; } return storage.set('saves', saves); } function _marshal(supplemental, details) { if (DEBUG) { console.log(`[Save/_marshal(…, { type : '${details.type}' })]`); } if (supplemental != null && typeof supplemental !== 'object') { throw new Error('supplemental parameter must be an object'); } const saveObj = Object.assign({}, supplemental, { id : Config.saves.id, state : State.marshalForSave(), idx : State.qc }); if (Config.saves.version) { saveObj.version = Config.saves.version; } _onSaveHandlers.forEach(fn => fn(saveObj, details)); saveObj.state.delta = State.deltaEncode(saveObj.state.history); delete saveObj.state.history; return saveObj; } function _unmarshal(saveObj) { if (DEBUG) { console.log('[Save/_unmarshal()]'); } try { if (!saveObj || !saveObj.hasOwnProperty('id') || !saveObj.hasOwnProperty('state')) { throw new Error(L10n.get('errorSaveMissingData')); } if (!saveObj.state.history) { if (saveObj.state.jdelta) { let corruptionTrigger = false; try { saveObj.state.history = State.jdeltaDecode(saveObj.state.delta, saveObj.state.jdelta); if (saveObj.state.history.find(s => typeof s !== 'object')) corruptionTrigger = true; } catch { corruptionTrigger = true; } if (corruptionTrigger) { alert('Corrupted jdelta detected, loading the last known state.'); saveObj.state.history = saveObj.state.delta; delete saveObj.state.realIndex; } delete saveObj.state.jdelta; } else if (saveObj.state.delta) { saveObj.state.history = State.deltaDecode(saveObj.state.delta); } delete saveObj.state.delta; } if (saveObj.state.realIndex) saveObj.state.index = saveObj.state.realIndex; _onLoadHandlers.forEach(fn => fn(saveObj)); if (saveObj.id !== Config.saves.id) throw new Error(L10n.get('errorSaveIdMismatch')); saveObj.state.idx = saveObj.idx || ''; State.unmarshalForSave(saveObj.state); Engine.show(); } catch (ex) { UI.alert(`${ex.message.toUpperFirst()}.</p><p>${L10n.get('aborting')}.`); return false; } return true; } /******************************************************************************************************************* Module Exports. *******************************************************************************************************************/ return Object.freeze(Object.defineProperties({}, { /* Save Functions. */ init : { value : savesInit }, get : { value : savesObjGet }, clear : { value : savesObjClear }, ok : { value : savesOk }, /* Autosave Functions. */ autosave : { value : Object.freeze(Object.defineProperties({}, { ok : { value : autosaveOk }, has : { value : autosaveHas }, get : { value : autosaveGet }, load : { value : autosaveLoad }, save : { value : autosaveSave }, delete : { value : autosaveDelete } })) }, /* Slots Functions. */ slots : { value : Object.freeze(Object.defineProperties({}, { ok : { value : slotsOk }, length : { get : slotsLength }, isEmpty : { value : slotsIsEmpty }, count : { value : slotsCount }, has : { value : slotsHas }, get : { value : slotsGet }, load : { value : slotsLoad }, save : { value : slotsSave }, delete : { value : slotsDelete } })) }, /* Disk Import/Export Functions. */ export : { value : exportToDisk }, import : { value : importFromDisk }, /* Serialization Functions. */ serialize : { value : serialize }, deserialize : { value : deserialize }, /* Event Functions. */ onLoad : { value : Object.freeze(Object.defineProperties({}, { add : { value : onLoadAdd }, clear : { value : onLoadClear }, delete : { value : onLoadDelete }, size : { get : onLoadSize }, handlers : { value : _onLoadHandlers } })) }, onSave : { value : Object.freeze(Object.defineProperties({}, { add : { value : onSaveAdd }, clear : { value : onSaveClear }, delete : { value : onSaveDelete }, size : { get : onSaveSize }, handlers : { value : _onSaveHandlers } })) }, meta : { get : () => _meta } })); })(); /*********************************************************************************************************************** setting.js Copyright © 2013–2021 Thomas Michael Edwards <thomasmedwards@gmail.com>. All rights reserved. Use of this source code is governed by a BSD 2-clause "Simplified" License, which may be found in the LICENSE file. ***********************************************************************************************************************/ var Setting = (() => { 'use strict'; const Types = Util.toEnum({ Header : 0, Toggle : 1, List : 2, Range : 3 }); const _definitions = []; /******************************************************************************************************************* Settings Functions. *******************************************************************************************************************/ function settingsInit() { if (DEBUG) { console.log('[Setting/settingsInit()]'); } if (storage.has('options')) { const old = storage.get('options'); if (old !== null) { window.SugarCube.settings = settings = Object.assign(settingsCreate(), old); } settingsSave(); storage.delete('options'); } settingsLoad(); _definitions.forEach(def => { if (def.hasOwnProperty('onInit')) { const thisArg = { name : def.name, value : settings[def.name], default : def.default }; if (def.hasOwnProperty('list')) { thisArg.list = def.list; } def.onInit.call(thisArg); } }); } function settingsCreate() { return Object.create(null); } function settingsSave() { const savedSettings = settingsCreate(); if (Object.keys(settings).length > 0) { _definitions .filter(def => def.type !== Types.Header && settings[def.name] !== def.default) .forEach(def => savedSettings[def.name] = settings[def.name]); } if (Object.keys(savedSettings).length === 0) { storage.delete('settings'); return true; } return storage.set('settings', savedSettings); } function settingsLoad() { const defaultSettings = settingsCreate(); const loadedSettings = storage.get('settings') || settingsCreate(); _definitions .filter(def => def.type !== Types.Header) .forEach(def => defaultSettings[def.name] = def.default); window.SugarCube.settings = settings = Object.assign(defaultSettings, loadedSettings); } function settingsClear() { window.SugarCube.settings = settings = settingsCreate(); storage.delete('settings'); return true; } function settingsReset(name) { if (arguments.length === 0) { settingsClear(); settingsLoad(); } else { if (name == null || !definitionsHas(name)) { throw new Error(`nonexistent setting "${name}"`); } const def = definitionsGet(name); if (def.type !== Types.Header) { settings[name] = def.default; } } return settingsSave(); } /******************************************************************************************************************* Definitions Functions. *******************************************************************************************************************/ function definitionsForEach(callback, thisArg) { _definitions.forEach(callback, thisArg); } function definitionsAdd(type, name, def) { if (arguments.length < 3) { const errors = []; if (arguments.length < 1) { errors.push('type'); } if (arguments.length < 2) { errors.push('name'); } if (arguments.length < 3) { errors.push('definition'); } throw new Error(`missing parameters, no ${errors.join(' or ')} specified`); } if (typeof def !== 'object') { throw new TypeError('definition parameter must be an object'); } if (definitionsHas(name)) { throw new Error(`cannot clobber existing setting "${name}"`); } /* Definition object properties and types: type → (all) → Setting.Types name → (all) → string label → (all) → string desc → (all) → string default (if defined) → Toggle → boolean → List → Array → Range → number (if undefined) → Toggle → false → List → list[0] → Range → max list → List → Array min → Range → number max → Range → number step → Range → number onInit → (all) → function onChange → (all) → function */ const definition = { type, name, label : typeof def.label === 'string' ? def.label.trim() : '' }; if (typeof def.desc === 'string') { const desc = def.desc.trim(); if (desc !== '') { definition.desc = desc; } } switch (type) { case Types.Header: break; case Types.Toggle: definition.default = !!def.default; break; case Types.List: if (!def.hasOwnProperty('list')) { throw new Error('no list specified'); } else if (!Array.isArray(def.list)) { throw new TypeError('list must be an array'); } else if (def.list.length === 0) { throw new Error('list must not be empty'); } definition.list = Object.freeze(def.list); if (def.default == null) { definition.default = def.list[0]; } else { const defaultIndex = def.list.indexOf(def.default); if (defaultIndex === -1) { throw new Error('list does not contain default'); } definition.default = def.list[defaultIndex]; } break; case Types.Range: if (!def.hasOwnProperty('min')) { throw new Error('no min specified'); } else if ( typeof def.min !== 'number' || Number.isNaN(def.min) || !Number.isFinite(def.min) ) { throw new TypeError('min must be a finite number'); } if (!def.hasOwnProperty('max')) { throw new Error('no max specified'); } else if ( typeof def.max !== 'number' || Number.isNaN(def.max) || !Number.isFinite(def.max) ) { throw new TypeError('max must be a finite number'); } if (!def.hasOwnProperty('step')) { throw new Error('no step specified'); } else if ( typeof def.step !== 'number' || Number.isNaN(def.step) || !Number.isFinite(def.step) || def.step <= 0 ) { throw new TypeError('step must be a finite number greater than zero'); } else { const fracDigits = (() => { const str = String(def.step); const pos = str.lastIndexOf('.'); return pos === -1 ? 0 : str.length - pos - 1; })(); function stepValidate(value) { if (fracDigits > 0) { const ma = Number(`${def.min}e${fracDigits}`); const sa = Number(`${def.step}e${fracDigits}`); const va = Number(`${value}e${fracDigits}`) - ma; return Number(`${va - va % sa + ma}e-${fracDigits}`); } const va = value - def.min; return va - va % def.step + def.min; } if (stepValidate(def.max) !== def.max) { throw new RangeError(`max (${def.max}) is not a multiple of the step (${def.step}) plus the min (${def.min})`); } } definition.max = def.max; definition.min = def.min; definition.step = def.step; if (def.default == null) { definition.default = def.max; } else { if ( typeof def.default !== 'number' || Number.isNaN(def.default) || !Number.isFinite(def.default) ) { throw new TypeError('default must be a finite number'); } else if (def.default < def.min) { throw new RangeError(`default (${def.default}) is less than min (${def.min})`); } else if (def.default > def.max) { throw new RangeError(`default (${def.default}) is greater than max (${def.max})`); } definition.default = def.default; } break; default: throw new Error(`unknown Setting type: ${type}`); } if (typeof def.onInit === 'function') { definition.onInit = Object.freeze(def.onInit); } if (typeof def.onChange === 'function') { definition.onChange = Object.freeze(def.onChange); } _definitions.push(Object.freeze(definition)); } function definitionsAddHeader(name, desc) { definitionsAdd(Types.Header, name, { desc }); } function definitionsAddToggle(...args) { definitionsAdd(Types.Toggle, ...args); } function definitionsAddList(...args) { definitionsAdd(Types.List, ...args); } function definitionsAddRange(...args) { definitionsAdd(Types.Range, ...args); } function definitionsIsEmpty() { return _definitions.length === 0; } function definitionsHas(name) { return _definitions.some(definition => definition.name === name); } function definitionsGet(name) { return _definitions.find(definition => definition.name === name); } function definitionsDelete(name) { if (definitionsHas(name)) { delete settings[name]; } for (let i = 0; i < _definitions.length; ++i) { if (_definitions[i].name === name) { _definitions.splice(i, 1); definitionsDelete(name); break; } } } /******************************************************************************************************************* Module Exports. *******************************************************************************************************************/ return Object.freeze(Object.defineProperties({}, { /* Enumerations. */ Types : { value : Types }, /* Settings Functions. */ init : { value : settingsInit }, create : { value : settingsCreate }, save : { value : settingsSave }, load : { value : settingsLoad }, clear : { value : settingsClear }, reset : { value : settingsReset }, /* Definitions Functions. */ forEach : { value : definitionsForEach }, add : { value : definitionsAdd }, addHeader : { value : definitionsAddHeader }, addToggle : { value : definitionsAddToggle }, addList : { value : definitionsAddList }, addRange : { value : definitionsAddRange }, isEmpty : { value : definitionsIsEmpty }, has : { value : definitionsHas }, get : { value : definitionsGet }, delete : { value : definitionsDelete } })); })(); /*********************************************************************************************************************** story.js Copyright © 2013–2021 Thomas Michael Edwards <thomasmedwards@gmail.com>. All rights reserved. Use of this source code is governed by a BSD 2-clause "Simplified" License, which may be found in the LICENSE file. ***********************************************************************************************************************/ var Story = (() => { 'use strict'; const _passages = {}; const _inits = []; const _scripts = []; const _styles = []; const _widgets = []; let _title = ''; let _ifId = ''; let _domId = ''; /******************************************************************************************************************* Story Functions. *******************************************************************************************************************/ function storyLoad() { if (DEBUG) { console.log('[Story/storyLoad()]'); } const validationCodeTags = [ 'init', 'widget' ]; const validationNoCodeTagPassages = [ 'PassageDone', 'PassageFooter', 'PassageHeader', 'PassageReady', 'StoryAuthor', 'StoryBanner', 'StoryCaption', 'StoryInit', 'StoryMenu', 'StoryShare', 'StorySubtitle' ]; function validateStartingPassage(passage) { if (passage.tags.includesAny(validationCodeTags)) { throw new Error(`starting passage "${passage.title}" contains special tags; invalid: "${passage.tags.filter(tag => validationCodeTags.includes(tag)).sort().join('", "')}"`); } } function validateSpecialPassages(passage, ...tags) { if (validationNoCodeTagPassages.includes(passage.title)) { throw new Error(`special passage "${passage.title}" contains special tags; invalid: "${tags.sort().join('", "')}"`); } const codeTags = [...validationCodeTags]; const foundTags = []; passage.tags.forEach(tag => { if (codeTags.includes(tag)) { foundTags.push(...codeTags.delete(tag)); } }); if (foundTags.length > 1) { throw new Error(`passage "${passage.title}" contains multiple special tags; invalid: "${foundTags.sort().join('", "')}"`); } } if (TWINE1) { /* Additional Twine 1 validation setup. */ validationCodeTags.unshift('script', 'stylesheet'); validationNoCodeTagPassages.push('StoryTitle'); /* Set the default starting passage. */ Config.passages.start = (() => { /* Handle the Twine 1.4+ Test Play From Here feature. WARNING: Do not remove the `String()` wrapper from or change the quote style of the `"START_AT"` replacement target. The former is there to keep UglifyJS from pruning the code into oblivion—i.e. minifying the code into something broken. The latter is there because the Twine 1 pattern that matches it depends upon the double quotes. */ const testPlay = String("START_AT"); if (testPlay !== '') { if (DEBUG) { console.log(`\tTest play; starting passage: "${testPlay}"`); } Config.debug = true; return testPlay; } return 'Start'; })(); /* Process the passages, excluding any tagged 'Twine.private' or 'annotation'. */ jQuery('#store-area') .children(':not([tags~="Twine.private"],[tags~="annotation"])') .each(function () { const $this = jQuery(this); const passage = new Passage($this.attr('tiddler'), this); if (passage.title === Config.passages.start) { validateStartingPassage(passage); _passages[passage.title] = passage; } else if (passage.tags.includes('init')) { validateSpecialPassages(passage, 'init'); _inits.push(passage); } else if (passage.tags.includes('stylesheet')) { validateSpecialPassages(passage, 'stylesheet'); _styles.push(passage); } else if (passage.tags.includes('script')) { validateSpecialPassages(passage, 'script'); _scripts.push(passage); } else if (passage.tags.includes('widget')) { validateSpecialPassages(passage, 'widget'); _widgets.push(passage); } else { _passages[passage.title] = passage; } }); /* Set the story title or throw an exception. */ if (_passages.hasOwnProperty('StoryTitle')) { const buf = document.createDocumentFragment(); new Wikifier(buf, _passages.StoryTitle.processText().trim(), undefined, _passages.StoryTitle); _storySetTitle(buf.textContent); } else { throw new Error('cannot find the "StoryTitle" special passage'); } /* Set the default saves ID (must be done after the call to `_storySetTitle()`). */ Config.saves.id = Story.domId; } else { const $storydata = jQuery('tw-storydata'); const startNode = $storydata.attr('startnode') || ''; /* Set the default starting passage. */ Config.passages.start = null; /* Process story options. NOTE: Currently, the only option of interest is 'debug', so we simply use a regular expression to check for it. */ Config.debug = /\bdebug\b/.test($storydata.attr('options')); /* Process stylesheet passages. */ $storydata .children('style') .each(function (i) { _styles.push(new Passage(`tw-user-style-${i}`, this)); }); /* Process script passages. */ $storydata .children('script') .each(function (i) { _scripts.push(new Passage(`tw-user-script-${i}`, this)); }); /* Process normal passages, excluding any tagged 'Twine.private' or 'annotation'. */ $storydata .children('tw-passagedata:not([tags~="Twine.private"],[tags~="annotation"])') .each(function () { const $this = jQuery(this); const pid = $this.attr('pid') || ''; const passage = new Passage($this.attr('name'), this); if (pid === startNode && startNode !== '') { Config.passages.start = passage.title; validateStartingPassage(passage); _passages[passage.title] = passage; } else if (passage.tags.includes('init')) { validateSpecialPassages(passage, 'init'); _inits.push(passage); } else if (passage.tags.includes('widget')) { validateSpecialPassages(passage, 'widget'); _widgets.push(passage); } else { _passages[passage.title] = passage; } }); /* Get the story IFID. */ _ifId = $storydata.attr('ifid'); /* Set the story title. FIXME: Maybe `$storydata.attr('name')` should be used instead of `'Degrees of Lewdity'`? */ _storySetTitle('Degrees of Lewdity'); /* Set the default saves ID (must be done after the call to `_storySetTitle()`). */ Config.saves.id = Story.domId; } } function storyInit() { if (DEBUG) { console.log('[Story/storyInit()]'); } /* Add the story styles. */ (() => { const storyStyle = document.createElement('style'); new StyleWrapper(storyStyle) .add(_styles.map(style => style.text.trim()).join('\n')); jQuery(storyStyle) .appendTo(document.head) .attr({ id : 'style-story', type : 'text/css' }); })(); /* Evaluate the story scripts. */ for (let i = 0; i < _scripts.length; ++i) { try { Scripting.evalJavaScript(_scripts[i].text); } catch (ex) { console.error(ex); Alert.error(_scripts[i].title, typeof ex === 'object' ? ex.message : ex); } } /* Process the story widgets. */ for (let i = 0; i < _widgets.length; ++i) { try { Wikifier.wikifyEval(_widgets[i].processText(), _widgets[i]); } catch (ex) { console.error(ex); Alert.error(_widgets[i].title, typeof ex === 'object' ? ex.message : ex); } } } function _storySetTitle(rawTitle) { if (rawTitle == null) { throw new Error('story title must not be null or undefined'); } const title = Util.unescape(String(rawTitle)).trim(); if (title === '') { throw new Error('story title must not be empty or consist solely of whitespace'); } document.title = _title = title; _domId = Util.slugify(_title); if (_domId === '') { if (_ifId !== '') { _domId = _ifId; } else { for (let i = 0, len = _title.length; i < len; ++i) { const { char, start, end } = Util.charAndPosAt(_title, i); _domId += char.codePointAt(0).toString(16); i += end - start; } } } } function storyTitle() { return _title; } function storyDomId() { return _domId; } function storyIfId() { return _ifId; } /******************************************************************************************************************* Passage Functions. *******************************************************************************************************************/ function passagesAdd(passage) { if (!(passage instanceof Passage)) { throw new TypeError('Story.add passage parameter must be an instance of Passage'); } const title = passage.title; if (!_passages.hasOwnProperty(title)) { _passages[title] = passage; return true; } return false; } function passagesHas(title) { let type = typeof title; switch (type) { case 'number': case 'string': return _passages.hasOwnProperty(String(title)); case 'undefined': break; case 'object': type = title === null ? 'null' : 'an object'; break; default: type = `a ${type}`; break; } throw new TypeError(`Story.has title parameter cannot be ${type}`); } function passagesGet(title) { let type = typeof title; switch (type) { case 'number': case 'string': { const id = String(title); return _passages.hasOwnProperty(id) ? _passages[id] : new Passage(id || '(unknown)'); } case 'undefined': break; case 'object': type = title === null ? 'null' : 'an object'; break; default: type = `a ${type}`; break; } throw new TypeError(`Story.get title parameter cannot be ${type}`); } function passagesGetAllInit() { return Object.freeze(Array.from(_inits)); } function passagesGetAllRegular() { return Object.freeze(Object.assign({}, _passages)); } function passagesGetAllScript() { return Object.freeze(Array.from(_scripts)); } function passagesGetAllStylesheet() { return Object.freeze(Array.from(_styles)); } function passagesGetAllWidget() { return Object.freeze(Array.from(_widgets)); } function passagesLookup(key, value , sortKey = 'title') { const results = []; Object.keys(_passages).forEach(name => { const passage = _passages[name]; if (typeof passage[key] === 'object' && passage[key] !== null) { if (passage[key] instanceof Array && passage[key].some(m => Util.sameValueZero(m, value))) { results.push(passage); } } else if (Util.sameValueZero(passage[key], value)) { results.push(passage); } }); results.sort((a, b) => a[sortKey] == b[sortKey] ? 0 : a[sortKey] < b[sortKey] ? -1 : +1); return results; } function passagesLookupWith(predicate , sortKey = 'title') { if (typeof predicate !== 'function') { throw new TypeError('Story.lookupWith predicate parameter must be a function'); } const results = []; Object.keys(_passages).forEach(name => { const passage = _passages[name]; if (predicate(passage)) { results.push(passage); } }); results.sort((a, b) => a[sortKey] == b[sortKey] ? 0 : a[sortKey] < b[sortKey] ? -1 : +1); return results; } /******************************************************************************************************************* Module Exports. *******************************************************************************************************************/ return Object.freeze(Object.defineProperties({}, { load : { value : storyLoad }, init : { value : storyInit }, title : { get : storyTitle }, domId : { get : storyDomId }, ifId : { get : storyIfId }, add : { value : passagesAdd }, has : { value : passagesHas }, get : { value : passagesGet }, getAllInit : { value : passagesGetAllInit }, getAllRegular : { value : passagesGetAllRegular }, getAllScript : { value : passagesGetAllScript }, getAllStylesheet : { value : passagesGetAllStylesheet }, getAllWidget : { value : passagesGetAllWidget }, lookup : { value : passagesLookup }, lookupWith : { value : passagesLookupWith } })); })(); /*********************************************************************************************************************** ui.js Copyright © 2013–2021 Thomas Michael Edwards <thomasmedwards@gmail.com>. All rights reserved. Use of this source code is governed by a BSD 2-clause "Simplified" License, which may be found in the LICENSE file. ***********************************************************************************************************************/ /* global Alert, Browser, Config, Dialog, Engine, Has, L10n, Save, Setting, State, Story, Util, Wikifier, idb errorPrologRegExp, settings */ var UI = (() => { 'use strict'; /******************************************************************************************************************* UI Functions, Core. *******************************************************************************************************************/ function uiAssembleLinkList(passage, listEl) { let list = listEl; const debugState = Config.debug; const cleanState = Config.cleanupWikifierOutput; Config.debug = false; Config.cleanupWikifierOutput = false; try { if (list == null) { list = document.createElement('ul'); } const frag = document.createDocumentFragment(); new Wikifier(frag, Story.get(passage).processText().trim(), undefined, Story.get(passage)); const errors = [...frag.querySelectorAll('.error')] .map(errEl => errEl.textContent.replace(errorPrologRegExp, '')); if (errors.length > 0) { throw new Error(errors.join('; ')); } while (frag.hasChildNodes()) { const node = frag.firstChild; if (node.nodeType === Node.ELEMENT_NODE && node.nodeName.toUpperCase() === 'A') { const li = document.createElement('li'); list.appendChild(li); li.appendChild(node); } else { frag.removeChild(node); } } } finally { Config.cleanupWikifierOutput = cleanState; Config.debug = debugState; } return list; } /******************************************************************************************************************* UI Functions, Built-ins. *******************************************************************************************************************/ function uiOpenAlert(message, ...args) { jQuery(Dialog.setup(L10n.get('alertTitle'), 'alert')) .append( `<p>${message}</p><ul class="buttons">` + `<li><button id="alert-ok" class="ui-close">${L10n.get(['alertOk', 'ok'])}</button></li>` + '</ul>' ); Dialog.open(...args); } function uiOpenJumpto( ...args) { uiBuildJumpto(); Dialog.open(...args); } function uiOpenRestart( ...args) { uiBuildRestart(); Dialog.open(...args); } function uiOpenSaves( ...args) { if (idb.active) { Dialog.create('saves', 'saves').append($(document.createElement('h3')).addClass('saves-loading').text('Loading the save list, please wait...')); idb.saveList(); } else uiBuildSaves(); Dialog.open(...args); } function uiOpenSettings( ...args) { uiBuildSettings(); Dialog.open(...args); } function uiOpenShare( ...args) { uiBuildShare(); Dialog.open(...args); } function uiBuildAutoload() { if (DEBUG) { console.log('[UI/uiBuildAutoload()]'); } jQuery(Dialog.setup(L10n.get('autoloadTitle'), 'autoload')) .append( `<p>${L10n.get('autoloadPrompt')}</p><ul class="buttons">` + `<li><button id="autoload-ok" class="ui-close">${L10n.get(['autoloadOk', 'ok'])}</button></li>` + `<li><button id="autoload-cancel" class="ui-close">${L10n.get(['autoloadCancel', 'cancel'])}</button></li>` + '</ul>' ); jQuery(document).one('click.autoload', '.ui-close', ev => { const isAutoloadOk = ev.target.id === 'autoload-ok'; jQuery(document).one(':dialogclosed', () => { if (DEBUG) { console.log(`\tattempting autoload: "${Save.autosave.get().title}"`); } if (!isAutoloadOk || !Save.autosave.load()) { Engine.play(Config.passages.start); } }); }); return true; } function uiBuildJumpto() { if (DEBUG) { console.log('[UI/uiBuildJumpto()]'); } const list = document.createElement('ul'); jQuery(Dialog.setup(L10n.get('jumptoTitle'), 'jumpto list')) .append(list); const expired = State.expired.length; for (let i = State.size - 1; i >= 0; --i) { if (i === State.activeIndex) { continue; } const passage = Story.get(State.history[i].title); if (passage && passage.tags.includes('bookmark')) { jQuery(document.createElement('li')) .append( jQuery(document.createElement('a')) .ariaClick({ one : true }, (function (idx) { return () => jQuery(document).one(':dialogclosed', () => Engine.goTo(idx)); })(i)) .addClass('ui-close') .text(`${L10n.get('jumptoTurn')} ${expired + i + 1}: ${passage.description()}`) ) .appendTo(list); } } if (!list.hasChildNodes()) { jQuery(list).append(`<li><a><em>${L10n.get('jumptoUnavailable')}</em></a></li>`); } } function uiBuildRestart() { if (DEBUG) { console.log('[UI/uiBuildRestart()]'); } jQuery(Dialog.setup(L10n.get('restartTitle'), 'restart')) .append( `<p>${L10n.get('restartPrompt')}</p><ul class="buttons">` + `<li><button id="restart-ok">${L10n.get(['restartOk', 'ok'])}</button></li>` + `<li><button id="restart-cancel" class="ui-close">${L10n.get(['restartCancel', 'cancel'])}</button></li>` + '</ul>' ) .find('#restart-ok') /* Instead of adding '.ui-close' to '#restart-ok' (to receive the use of the default delegated dialog close handler), we set up a special case close handler here. We do this to ensure that the invocation of `Engine.restart()` happens after the dialog has fully closed. If we did not, then a race condition could occur, causing display shenanigans. */ .ariaClick({ one : true }, () => { jQuery(document).one(':dialogclosed', () => Engine.restart()); Dialog.close(); }); return true; } function uiBuildSaves() { const savesAllowed = typeof Config.saves.isAllowed !== 'function' || Config.saves.isAllowed(); function createActionItem(bId, bClass, bText, bAction) { const $btn = jQuery(document.createElement('button')) .attr('id', `saves-${bId}`) .html(bText); if (bClass) { $btn.addClass(bClass); } if (bAction) { $btn.ariaClick(bAction); } else { $btn.ariaDisabled(true); } return jQuery(document.createElement('li')) .append($btn); } function createSaveList() { function createButton(bId, bClass, bText, bSlot, bAction) { const $btn = jQuery(document.createElement('button')) .attr('id', `saves-${bId}-${bSlot}`) .addClass(bId) .html(bText); if (bClass) { $btn.addClass(bClass); } if (bAction) { if (bSlot === 'auto') { $btn.ariaClick({ label : `${bText} ${L10n.get('savesLabelAuto')}` }, () => bAction()); } else { $btn.ariaClick({ label : `${bText} ${L10n.get('savesLabelSlot')} ${bSlot + 1}` }, () => bAction(bSlot)); } } else { $btn.ariaDisabled(true); } return $btn; } const saves = Save.get(); const $tbody = jQuery(document.createElement('tbody')); if (Save.autosave.ok()) { const $tdSlot = jQuery(document.createElement('td')); const $tdLoad = jQuery(document.createElement('td')); const $tdDesc = jQuery(document.createElement('td')); const $tdDele = jQuery(document.createElement('td')); jQuery(document.createElement('b')) .attr({ title : L10n.get('savesLabelAuto'), 'aria-label' : L10n.get('savesLabelAuto') }) .text('A') .appendTo($tdSlot); if (saves.autosave) { $tdLoad.append( createButton('load', 'ui-close', L10n.get('savesLabelLoad'), 'auto', () => { jQuery(document).one(':dialogclosed', () => Save.autosave.load()); }) ); jQuery(document.createElement('div')) .text(saves.autosave.title) .appendTo($tdDesc); jQuery(document.createElement('div')) .addClass('datestamp') .html( saves.autosave.date ? `${new Date(saves.autosave.date).toLocaleString()}` : `<em>${L10n.get('savesUnknownDate')}</em>` ) .appendTo($tdDesc); $tdDele.append( createButton('delete', null, L10n.get('savesLabelDelete'), 'auto', () => { Save.autosave.delete(); uiBuildSaves(); }) ); } else { $tdLoad.append( createButton('load', null, L10n.get('savesLabelLoad'), 'auto') ); $tdDesc.addClass('empty').text('\u2022\u00a0\u00a0\u2022\u00a0\u00a0\u2022'); $tdDele.append( createButton('delete', null, L10n.get('savesLabelDelete'), 'auto') ); } jQuery(document.createElement('tr')) .append($tdSlot) .append($tdLoad) .append($tdDesc) .append($tdDele) .appendTo($tbody); } for (let i = 0, iend = saves.slots.length; i < iend; ++i) { const $tdSlot = jQuery(document.createElement('td')); const $tdLoad = jQuery(document.createElement('td')); const $tdDesc = jQuery(document.createElement('td')); const $tdDele = jQuery(document.createElement('td')); $tdSlot.append(document.createTextNode(i + 1)); if (saves.slots[i]) { $tdLoad.append( createButton('save', 'ui-close', L10n.get('savesLabelSave'), i, Save.slots.save), createButton('load', 'ui-close', L10n.get('savesLabelLoad'), i, slot => { jQuery(document).one(':dialogclosed', () => Save.slots.load(slot)); }) ); jQuery(document.createElement('div')) .text(saves.slots[i].title) .appendTo($tdDesc); jQuery(document.createElement('div')) .addClass('datestamp') .html( saves.slots[i].date ? `${new Date(saves.slots[i].date).toLocaleString()}` : `<em>${L10n.get('savesUnknownDate')}</em>` ) .appendTo($tdDesc); $tdDele.append( createButton('delete', null, L10n.get('savesLabelDelete'), i, slot => { Save.slots.delete(slot); uiBuildSaves(); }) ); } else { $tdLoad.append( createButton('save', 'ui-close', L10n.get('savesLabelSave'), i, savesAllowed ? Save.slots.save : null) ); $tdDesc.addClass('empty').text('\u2022\u00a0\u00a0\u2022\u00a0\u00a0\u2022'); $tdDele.append( createButton('delete', null, L10n.get('savesLabelDelete'), i) ); } jQuery(document.createElement('tr')) .append($tdSlot) .append($tdLoad) .append($tdDesc) .append($tdDele) .appendTo($tbody); } return jQuery(document.createElement('table')) .attr('id', 'saves-list') .append($tbody); } if (DEBUG) { console.log('[UI/uiBuildSaves()]'); } const $dialogBody = jQuery(Dialog.setup(L10n.get('savesTitle'), 'saves')); const savesOk = Save.ok(); const fileOk = Has.fileAPI && (Config.saves.tryDiskOnMobile || !Browser.isMobile.any()); if (savesOk) { $dialogBody.append(createSaveList()); } jQuery(document.createElement('label')).attr('id', 'idbToggleSaves').append( jQuery(document.createElement('input')) .attr({ id : 'checkbox-idbactive', name : 'checkbox-idbactive', type : 'checkbox', checked : idb.active && !V.ironmanmode, disabled : idb.lock || V.ironmanmode }) .addClass('macro-checkbox') .on('change.macros', () => { idb.active = document.getElementById('checkbox-idbactive').checked; if (idb.active) { sessionStorage.removeItem('noidb'); setTimeout(()=>idb.saveList()); } }) ) .appendTo($dialogBody) .append(' Enable indexedDB '); if (savesOk || fileOk) { const $btnBar = jQuery(document.createElement('ul')) .addClass('buttons') .appendTo($dialogBody); if (fileOk) { $btnBar.append(createActionItem( 'export', 'ui-close', L10n.get('savesLabelExport'), savesAllowed ? () => Save.export() : null )); if (navigator.clipboard) { $btnBar.append(createActionItem( 'toClipboard', 'ui-close', L10n.get('savesLabelToClipboard'), savesAllowed ? () => navigator.clipboard.writeText(Save.serialize()) : null )); } $btnBar.append(createActionItem( 'import', null, L10n.get('savesLabelImport'), () => $dialogBody.find('#saves-import-file').trigger('click') )); jQuery(document.createElement('input')) .css({ display : 'block', visibility : 'hidden', position : 'fixed', left : '-9999px', top : '-9999px', width : '1px', height : '1px' }) .attr({ type : 'file', id : 'saves-import-file', tabindex : -1, 'aria-hidden' : true }) .on('change', ev => { jQuery(document).one(':dialogclosed', () => Save.import(ev)); Dialog.close(); }) .appendTo($dialogBody); } if (savesOk) { $btnBar.append(createActionItem( 'clear', null, L10n.get('savesLabelClear'), Save.autosave.has() || !Save.slots.isEmpty() ? () => { Save.clear(); uiBuildSaves(); } : null )); } const $idbBar = jQuery(document.createElement('ul')) .addClass('buttons') .appendTo($dialogBody); $idbBar.append(createActionItem( 'idbToggleSaves', null, 'Enable indexedDB', !idb.lock ? () => { Dialog.create('saves', 'saves').append($(document.createElement('h3')).addClass('saves-loading').text('Loading the save list, please wait...')); idb.updateSettings('active', true); idb.saveList(); } : null )); return true; } uiOpenAlert(L10n.get('savesIncapable')); return false; } function uiBuildSettings() { if (DEBUG) { console.log('[UI/uiBuildSettings()]'); } const $dialogBody = jQuery(Dialog.setup(L10n.get('settingsTitle'), 'settings')); Setting.forEach(control => { if (control.type === Setting.Types.Header) { const name = control.name; const id = Util.slugify(name); const $header = jQuery(document.createElement('div')); const $heading = jQuery(document.createElement('h2')); $header .attr('id', `header-body-${id}`) .append($heading) .appendTo($dialogBody); $heading .attr('id', `header-heading-${id}`) .wiki(name); if (control.desc) { jQuery(document.createElement('p')) .attr('id', `header-desc-${id}`) .wiki(control.desc) .appendTo($header); } return; } const name = control.name; const id = Util.slugify(name); const $setting = jQuery(document.createElement('div')); const $label = jQuery(document.createElement('label')); const $controlBox = jQuery(document.createElement('div')); let $control; jQuery(document.createElement('div')) .append($label) .append($controlBox) .appendTo($setting); if (control.desc) { jQuery(document.createElement('p')) .attr('id', `setting-desc-${id}`) .wiki(control.desc) .appendTo($setting); } $label .attr({ id : `setting-label-${id}`, for : `setting-control-${id}` }) .wiki(control.label); if (settings[name] == null) { settings[name] = control.default; } switch (control.type) { case Setting.Types.Toggle: $control = jQuery(document.createElement('button')); if (settings[name]) { $control .addClass('enabled') .text(L10n.get('settingsOn')); } else { $control .text(L10n.get('settingsOff')); } $control.ariaClick(function () { if (settings[name]) { jQuery(this) .removeClass('enabled') .text(L10n.get('settingsOff')); settings[name] = false; } else { jQuery(this) .addClass('enabled') .text(L10n.get('settingsOn')); settings[name] = true; } Setting.save(); if (control.hasOwnProperty('onChange')) { control.onChange.call({ name, value : settings[name], default : control.default }); } }); break; case Setting.Types.List: $control = jQuery(document.createElement('select')); for (let i = 0, iend = control.list.length; i < iend; ++i) { jQuery(document.createElement('option')) .val(i) .text(control.list[i]) .appendTo($control); } $control .val(control.list.indexOf(settings[name])) .attr('tabindex', 0) .on('change', function () { settings[name] = control.list[Number(this.value)]; Setting.save(); if (control.hasOwnProperty('onChange')) { control.onChange.call({ name, value : settings[name], default : control.default, list : control.list }); } }); break; case Setting.Types.Range: $control = jQuery(document.createElement('input')); $control .attr({ type : 'range', min : control.min, max : control.max, step : control.step, value : settings[name], tabindex : 0 }) .on('change input', function () { settings[name] = Number(this.value); Setting.save(); if (control.hasOwnProperty('onChange')) { control.onChange.call({ name, value : settings[name], default : control.default, min : control.min, max : control.max, step : control.step }); } }) .on('keypress', ev => { if (ev.which === 13) { ev.preventDefault(); $control.trigger('change'); } }); break; } $control .attr('id', `setting-control-${id}`) .appendTo($controlBox); $setting .attr('id', `setting-body-${id}`) .appendTo($dialogBody); }); $dialogBody .append( '<ul class="buttons">' + `<li><button id="settings-ok" class="ui-close">${L10n.get(['settingsOk', 'ok'])}</button></li>` + `<li><button id="settings-reset">${L10n.get('settingsReset')}</button></li>` + '</ul>' ) .find('#settings-reset') /* Instead of adding '.ui-close' to '#settings-reset' (to receive the use of the default delegated dialog close handler), we set up a special case close handler here. We do this to ensure that the invocation of `window.location.reload()` happens after the dialog has fully closed. If we did not, then a race condition could occur, causing display shenanigans. */ .ariaClick({ one : true }, () => { jQuery(document).one(':dialogclosed', () => { Setting.reset(); window.location.reload(); }); Dialog.close(); }); return true; } function uiBuildShare() { if (DEBUG) { console.log('[UI/uiBuildShare()]'); } try { jQuery(Dialog.setup(L10n.get('shareTitle'), 'share list')) .append(uiAssembleLinkList('StoryShare')); } catch (ex) { console.error(ex); Alert.error('StoryShare', ex.message); return false; } return true; } /******************************************************************************************************************* Module Exports. *******************************************************************************************************************/ return Object.freeze(Object.defineProperties({}, { /* UI Functions, Core. */ assembleLinkList : { value : uiAssembleLinkList }, /* UI Functions, Built-ins. */ alert : { value : uiOpenAlert }, jumpto : { value : uiOpenJumpto }, restart : { value : uiOpenRestart }, saves : { value : uiOpenSaves }, settings : { value : uiOpenSettings }, share : { value : uiOpenShare }, buildAutoload : { value : uiBuildAutoload }, buildJumpto : { value : uiBuildJumpto }, buildRestart : { value : uiBuildRestart }, buildSaves : { value : uiBuildSaves }, buildSettings : { value : uiBuildSettings }, buildShare : { value : uiBuildShare }, /* Legacy Aliases. */ stow : { value : () => UIBar.stow() }, unstow : { value : () => UIBar.unstow() }, setStoryElements : { value : () => UIBar.update() }, isOpen : { value : (...args) => Dialog.isOpen(...args) }, body : { value : () => Dialog.body() }, setup : { value : (...args) => Dialog.setup(...args) }, addClickHandler : { value : (...args) => Dialog.addClickHandler(...args) }, open : { value : (...args) => Dialog.open(...args) }, close : { value : (...args) => Dialog.close(...args) }, resize : { value : () => Dialog.resize() }, buildDialogAutoload : { value : uiBuildAutoload }, buildDialogJumpto : { value : uiBuildJumpto }, buildDialogRestart : { value : uiBuildRestart }, buildDialogSaves : { value : uiBuildSaves }, buildDialogSettings : { value : uiBuildSettings }, buildDialogShare : { value : uiBuildShare }, buildLinkListFromPassage : { value : uiAssembleLinkList } })); })(); /*********************************************************************************************************************** uibar.js Copyright © 2013–2021 Thomas Michael Edwards <thomasmedwards@gmail.com>. All rights reserved. Use of this source code is governed by a BSD 2-clause "Simplified" License, which may be found in the LICENSE file. ***********************************************************************************************************************/ /* global Alert, Dialog, Engine, L10n, Setting, State, Story, UI, Config, setDisplayTitle, setPageElement */ var UIBar = (() => { 'use strict'; let _$uiBar = null; /******************************************************************************* UI Bar Functions. *******************************************************************************/ function uiBarDestroy() { if (DEBUG) { console.log('[UIBar/uiBarDestroy()]'); } if (!_$uiBar) { return; } _$uiBar.hide(); jQuery(document).off('.ui-bar'); jQuery(document.head).find('#style-ui-bar').remove(); _$uiBar.remove(); _$uiBar = null; } function uiBarHide() { if (_$uiBar) { _$uiBar.hide(); } return this; } function uiBarInit() { if (DEBUG) { console.log('[UIBar/uiBarInit()]'); } if (document.getElementById('ui-bar')) { return; } const $elems = (() => { const toggleLabel = L10n.get('uiBarToggle'); const backwardLabel = L10n.get('uiBarBackward'); const jumptoLabel = L10n.get('uiBarJumpto'); const forwardLabel = L10n.get('uiBarForward'); return jQuery(document.createDocumentFragment()) .append( '<div id="ui-bar" aria-live="polite">' + '<div id="ui-bar-tray">' + `<button id="ui-bar-toggle" tabindex="0" title="${toggleLabel}" aria-label="${toggleLabel}"></button>` + '<div id="ui-bar-history">' + `<button id="history-backward" tabindex="0" title="${backwardLabel}" aria-label="${backwardLabel}">\uE821</button>` + `<button id="history-jumpto" tabindex="0" title="${jumptoLabel}" aria-label="${jumptoLabel}">\uE839</button>` + `<button id="history-forward" tabindex="0" title="${forwardLabel}" aria-label="${forwardLabel}">\uE822</button>` + '</div>' + '</div>' + '<div id="ui-bar-body">' + '<header id="title" role="banner">' + '<div id="story-banner"></div>' + '<h1 id="story-title"></h1>' + '<div id="story-subtitle"></div>' + '<div id="story-title-separator"></div>' + '<p id="story-author"></p>' + '</header>' + '<div id="story-caption"></div>' + '<nav id="menu" role="navigation">' + '<ul id="menu-story"></ul>' + '<ul id="menu-core">' + `<li id="menu-item-saves"><a tabindex="0">${L10n.get('savesTitle')}</a></li>` + `<li id="menu-item-settings"><a tabindex="0">${L10n.get('settingsTitle')}</a></li>` + `<li id="menu-item-restart"><a tabindex="0">${L10n.get('restartTitle')}</a></li>` + `<li id="menu-item-share"><a tabindex="0">${L10n.get('shareTitle')}</a></li>` + '</ul>' + '</nav>' + '</div>' + '</div>' ); })(); /* Cache the UI bar element, since its going to be used often. NOTE: We rewrap the element itself, rather than simply using the result of `find()`, so that we cache an uncluttered jQuery-wrapper (i.e. `context` refers to the element and there is no `prevObject`). */ _$uiBar = jQuery($elems.find('#ui-bar').get(0)); $elems.insertBefore('body>script#script-sugarcube'); jQuery(document) .on(':historyupdate.ui-bar', (($backward, $forward) => () => { $backward.ariaDisabled(State.length < 2); $forward.ariaDisabled(State.length === State.size); })(jQuery('#history-backward'), jQuery('#history-forward'))); } function uiBarIsHidden() { return _$uiBar && _$uiBar.css('display') === 'none'; } function uiBarIsStowed() { return _$uiBar && _$uiBar.hasClass('stowed'); } function uiBarShow() { if (_$uiBar) { _$uiBar.show(); } return this; } function uiBarStart() { if (DEBUG) { console.log('[UIBar/uiBarStart()]'); } if (!_$uiBar) { return; } if ( typeof Config.ui.stowBarInitially === 'boolean' ? Config.ui.stowBarInitially : jQuery(window).width() <= Config.ui.stowBarInitially ) { uiBarStow(true); } jQuery('#ui-bar-toggle') .ariaClick({ label : L10n.get('uiBarToggle') }, () => _$uiBar.toggleClass('stowed')); jQuery('#history-backward') .ariaDisabled(State.length < 2) .ariaClick({ label : L10n.get('uiBarBackward') }, () => Engine.backward()); if (Story.lookup('tags', 'bookmark').length > 0) { jQuery('#history-jumpto') .ariaClick({ label : L10n.get('uiBarJumpto') }, () => UI.jumpto()); } else { jQuery('#history-jumpto').remove(); } jQuery('#history-forward') .ariaDisabled(State.length === State.size) .ariaClick({ label : L10n.get('uiBarForward') }, () => Engine.forward()); if (!Config.history.controls) jQuery('#ui-bar-history').hide(); if (Story.has('StoryDisplayTitle')) { setDisplayTitle(Story.get('StoryDisplayTitle').processText()); } else { if (TWINE1) { setPageElement('story-title', 'StoryTitle', Story.title); } else { jQuery('#story-title').text(Story.title); } } if (!Story.has('StoryCaption')) { jQuery('#story-caption').remove(); } if (!Story.has('StoryMenu')) { jQuery('#menu-story').remove(); } if (!Config.ui.updateStoryElements) { uiBarUpdate(); } jQuery('#menu-item-saves a') .ariaClick({ role : 'button' }, ev => { ev.preventDefault(); if (idb.active) { Dialog.create('saves', 'saves').append($(document.createElement('h3')).addClass('saves-loading').text('Loading the save list, please wait...')); idb.saveList(); } else UI.buildSaves(); Dialog.open(); }) .text(L10n.get('savesTitle')); if (!Setting.isEmpty()) { jQuery('#menu-item-settings a') .ariaClick({ role : 'button' }, ev => { ev.preventDefault(); UI.buildSettings(); Dialog.open(); }) .text(L10n.get('settingsTitle')); } else { jQuery('#menu-item-settings').remove(); } jQuery('#menu-item-restart a') .ariaClick({ role : 'button' }, ev => { ev.preventDefault(); UI.buildRestart(); Dialog.open(); }) .text(L10n.get('restartTitle')); if (Story.has('StoryShare')) { jQuery('#menu-item-share a') .ariaClick({ role : 'button' }, ev => { ev.preventDefault(); UI.buildShare(); Dialog.open(); }) .text(L10n.get('shareTitle')); } else { jQuery('#menu-item-share').remove(); } } function uiBarStow(noAnimation) { if (_$uiBar && !_$uiBar.hasClass('stowed')) { let $story; if (noAnimation) { $story = jQuery('#story'); $story.addClass('no-transition'); _$uiBar.addClass('no-transition'); } _$uiBar.addClass('stowed'); if (noAnimation) { setTimeout(() => { $story.removeClass('no-transition'); _$uiBar.removeClass('no-transition'); }, Engine.minDomActionDelay); } } return this; } function uiBarUnstow(noAnimation) { if (_$uiBar && _$uiBar.hasClass('stowed')) { let $story; if (noAnimation) { $story = jQuery('#story'); $story.addClass('no-transition'); _$uiBar.addClass('no-transition'); } _$uiBar.removeClass('stowed'); if (noAnimation) { setTimeout(() => { $story.removeClass('no-transition'); _$uiBar.removeClass('no-transition'); }, Engine.minDomActionDelay); } } return this; } function uiBarUpdate() { if (DEBUG) { console.log('[UIBar/uiBarUpdate()]'); } if (Story.has('StoryDisplayTitle')) { setDisplayTitle(Story.get('StoryDisplayTitle').processText()); } if (!_$uiBar) { return; } setPageElement('story-banner', 'StoryBanner'); setPageElement('story-subtitle', 'StorySubtitle'); setPageElement('story-author', 'StoryAuthor'); setPageElement('story-caption', 'StoryCaption'); const menuStory = document.getElementById('menu-story'); if (menuStory !== null) { jQuery(menuStory).empty(); if (Story.has('StoryMenu')) { try { UI.assembleLinkList('StoryMenu', menuStory); } catch (ex) { console.error(ex); Alert.error('StoryMenu', ex.message); } } } } /******************************************************************************* Object Exports. *******************************************************************************/ return Object.freeze(Object.defineProperties({}, { destroy : { value : uiBarDestroy }, hide : { value : uiBarHide }, init : { value : uiBarInit }, isHidden : { value : uiBarIsHidden }, isStowed : { value : uiBarIsStowed }, show : { value : uiBarShow }, start : { value : uiBarStart }, stow : { value : uiBarStow }, unstow : { value : uiBarUnstow }, update : { value : uiBarUpdate }, setStoryElements : { value : uiBarUpdate } })); })(); /*********************************************************************************************************************** debugbar.js Copyright © 2013–2021 Thomas Michael Edwards <thomasmedwards@gmail.com>. All rights reserved. Use of this source code is governed by a BSD 2-clause "Simplified" License, which may be found in the LICENSE file. ***********************************************************************************************************************/ /* global DebugView, Engine, L10n, Patterns, State, Util, session */ var DebugBar = (() => { 'use strict'; const _variableRe = new RegExp(`^${Patterns.variable}$`); const _numericKeyRe = /^\d+$/; const _watchList = []; let _$debugBar = null; let _$watchBody = null; let _$watchList = null; let _$turnSelect = null; let _stowed = true; /******************************************************************************************************************* Debug Bar Functions. *******************************************************************************************************************/ function debugBarInit() { if (DEBUG) { console.log('[DebugBar/debugBarInit()]'); } /* Generate the debug bar elements and append them to the `<body>`. */ const barToggleLabel = L10n.get('debugBarToggle'); const watchAddLabel = L10n.get('debugBarAddWatch'); const watchAllLabel = L10n.get('debugBarWatchAll'); const watchNoneLabel = L10n.get('debugBarWatchNone'); const watchToggleLabel = L10n.get('debugBarWatchToggle'); const viewsToggleLabel = L10n.get('debugBarViewsToggle'); jQuery(document.createDocumentFragment()) .append( '<div id="debug-bar">' + '<div id="debug-bar-watch">' + `<div>${L10n.get('debugBarNoWatches')}</div>>` + '</div>' + '<div>' + `<button id="debug-bar-watch-toggle" tabindex="0" title="${watchToggleLabel}" aria-label="${watchToggleLabel}">${L10n.get('debugBarLabelWatch')}</button>` + `<label id="debug-bar-watch-label" for="debug-bar-watch-input">${L10n.get('debugBarLabelAdd')}</label>` + '<input id="debug-bar-watch-input" name="debug-bar-watch-input" type="text" list="debug-bar-watch-list" tabindex="0">' + '<datalist id="debug-bar-watch-list" aria-hidden="true" hidden="hidden"></datalist>' + `<button id="debug-bar-watch-add" tabindex="0" title="${watchAddLabel}" aria-label="${watchAddLabel}"></button>` + `<button id="debug-bar-watch-all" tabindex="0" title="${watchAllLabel}" aria-label="${watchAllLabel}"></button>` + `<button id="debug-bar-watch-none" tabindex="0" title="${watchNoneLabel}" aria-label="${watchNoneLabel}"></button>` + '</div>' + '<div>' + `<button id="debug-bar-views-toggle" tabindex="0" title="${viewsToggleLabel}" aria-label="${viewsToggleLabel}">${L10n.get('debugBarLabelViews')}</button>` + `<label id="debug-bar-turn-label" for="debug-bar-turn-select">${L10n.get('debugBarLabelTurn')}</label>` + '<select id="debug-bar-turn-select" tabindex="0"></select>' + '</div>' + `<button id="debug-bar-toggle" tabindex="0" title="${barToggleLabel}" aria-label="${barToggleLabel}"></button>` + '</div>' + '<div id="debug-bar-hint"></div>' ) .appendTo('body'); /* Cache various oft used elements. NOTE: We rewrap the elements themselves, rather than simply using the results of `find()`, so that we cache uncluttered jQuery-wrappers (i.e. `context` refers to the elements and there is no `prevObject`). */ _$debugBar = jQuery('#debug-bar'); _$watchBody = jQuery(_$debugBar.find('#debug-bar-watch').get(0)); _$watchList = jQuery(_$debugBar.find('#debug-bar-watch-list').get(0)); _$turnSelect = jQuery(_$debugBar.find('#debug-bar-turn-select').get(0)); const $barToggle = jQuery(_$debugBar.find('#debug-bar-toggle').get(0)); const $watchToggle = jQuery(_$debugBar.find('#debug-bar-watch-toggle').get(0)); const $watchInput = jQuery(_$debugBar.find('#debug-bar-watch-input').get(0)); const $watchAdd = jQuery(_$debugBar.find('#debug-bar-watch-add').get(0)); const $watchAll = jQuery(_$debugBar.find('#debug-bar-watch-all').get(0)); const $watchNone = jQuery(_$debugBar.find('#debug-bar-watch-none').get(0)); const $viewsToggle = jQuery(_$debugBar.find('#debug-bar-views-toggle').get(0)); /* Set up the debug bar's local event handlers. */ $barToggle .ariaClick(debugBarToggle); $watchToggle .ariaClick(debugBarWatchToggle); $watchInput .on(':addwatch', function () { debugBarWatchAdd(this.value.trim()); this.value = ''; }) .on('keypress', ev => { if (ev.which === 13) { ev.preventDefault(); $watchInput.trigger(':addwatch'); } }); $watchAdd .ariaClick(() => $watchInput.trigger(':addwatch')); $watchAll .ariaClick(debugBarWatchAddAll); $watchNone .ariaClick(debugBarWatchClear); _$turnSelect .on('change', function () { Engine.goTo(Number(this.value)); }); $viewsToggle .ariaClick(() => { DebugView.toggle(); _updateSession(); }); /* Set up the debug bar's global event handlers. */ jQuery(document) .on(':historyupdate.debug-bar', _updateTurnSelect) .on(':passageend.debug-bar', () => { _updateWatchBody(); _updateWatchList(); }) .on(':enginerestart.debug-bar', _clearSession); /* Initially enable debug views if there's no active debug session. */ if (!_hasSession()) { DebugView.enable(); } } function debugBarStart() { if (DEBUG) { console.log('[DebugBar/debugBarStart()]'); } _restoreSession(); _updateBar(); _updateTurnSelect(); _updateWatchBody(); _updateWatchList(); } function debugBarIsStowed() { return _stowed; } function debugBarStow() { _debugBarStowNoUpdate(); _stowed = true; _updateSession(); } function debugBarUnstow() { _debugBarUnstowNoUpdate(); _stowed = false; _updateSession(); } function debugBarToggle() { if (_stowed) { debugBarUnstow(); } else { debugBarStow(); } } function debugBarWatchAdd(varName) { if (!_variableRe.test(varName)) { return; } _watchList.pushUnique(varName); _watchList.sort(); _updateWatchBody(); _updateWatchList(); _updateSession(); } function debugBarWatchAddAll() { Object.keys(State.variables).map(name => _watchList.pushUnique(`$${name}`)); Object.keys(State.temporary).map(name => _watchList.pushUnique(`_${name}`)); _watchList.sort(); _updateWatchBody(); _updateWatchList(); _updateSession(); } function debugBarWatchClear() { for (let i = _watchList.length - 1; i >= 0; --i) { _watchList.pop(); } _updateWatchBody(); _updateWatchList(); _updateSession(); } function debugBarWatchDelete(varName) { _watchList.delete(varName); _updateWatchBody(); _updateWatchList(); _updateSession(); } function debugBarWatchDisable() { _debugBarWatchDisableNoUpdate(); _updateSession(); } function debugBarWatchEnable() { _debugBarWatchEnableNoUpdate(); _updateSession(); } function debugBarWatchIsEnabled() { return !_$watchBody.attr('hidden'); } function debugBarWatchToggle() { if (_$watchBody.attr('hidden')) { debugBarWatchEnable(); } else { debugBarWatchDisable(); } } /******************************************************************************************************************* Utility Functions. *******************************************************************************************************************/ function _debugBarStowNoUpdate() { _$debugBar.css('right', `-${_$debugBar.outerWidth()}px`); } function _debugBarUnstowNoUpdate() { _$debugBar.css('right', 0); } function _debugBarWatchDisableNoUpdate() { _$watchBody.attr({ 'aria-hidden' : true, hidden : 'hidden' }); } function _debugBarWatchEnableNoUpdate() { _$watchBody.removeAttr('aria-hidden hidden'); } function _clearSession() { session.delete('debugState'); } function _hasSession() { return session.has('debugState'); } function _restoreSession() { if (!_hasSession()) { return false; } const debugState = session.get('debugState'); _stowed = debugState.stowed; _watchList.push(...debugState.watchList); if (debugState.watchEnabled) { _debugBarWatchEnableNoUpdate(); } else { _debugBarWatchDisableNoUpdate(); } if (debugState.viewsEnabled) { DebugView.enable(); } else { DebugView.disable(); } return true; } function _updateSession() { session.set('debugState', { stowed : _stowed, watchList : _watchList, watchEnabled : debugBarWatchIsEnabled(), viewsEnabled : DebugView.isEnabled() }); } function _updateBar() { if (_stowed) { debugBarStow(); } else { debugBarUnstow(); } } function _updateWatchBody() { if (_watchList.length === 0) { _$watchBody .empty() .append(`<div>${L10n.get('debugBarNoWatches')}</div>`); return; } const delLabel = L10n.get('debugBarDeleteWatch'); const $table = jQuery(document.createElement('table')); const $tbody = jQuery(document.createElement('tbody')); for (let i = 0, len = _watchList.length; i < len; ++i) { const varName = _watchList[i]; const varKey = varName.slice(1); const store = varName[0] === '$' ? State.variables : State.temporary; const $row = jQuery(document.createElement('tr')); const $delBtn = jQuery(document.createElement('button')); const $code = jQuery(document.createElement('code')); $delBtn .addClass('watch-delete') .attr('data-name', varName) .ariaClick({ one : true, label : delLabel }, () => debugBarWatchDelete(varName)); $code .text(_toWatchString(store[varKey])); jQuery(document.createElement('td')) .append($delBtn) .appendTo($row); jQuery(document.createElement('td')) .text(varName) .appendTo($row); jQuery(document.createElement('td')) .append($code) .appendTo($row); $row .appendTo($tbody); } $table .append($tbody); _$watchBody .empty() .append($table); } function _updateWatchList() { const svn = Object.keys(State.variables); const tvn = Object.keys(State.temporary); if (svn.length === 0 && tvn.length === 0) { _$watchList.empty(); return; } const names = [...svn.map(name => `$${name}`), ...tvn.map(name => `_${name}`)].sort(); const options = document.createDocumentFragment(); names.delete(_watchList); for (let i = 0, len = names.length; i < len; ++i) { jQuery(document.createElement('option')) .val(names[i]) .appendTo(options); } _$watchList .empty() .append(options); } function _updateTurnSelect() { const histLen = State.size; const expLen = State.expired.length; const options = document.createDocumentFragment(); for (let i = 0; i < histLen; ++i) { jQuery(document.createElement('option')) .val(i) .text(`${expLen + i + 1}. ${Util.escape(State.history[i].title)}`) .appendTo(options); } _$turnSelect .empty() .ariaDisabled(histLen < 2) .append(options) .val(State.activeIndex); } function _toWatchString(value) { /* Handle the `null` primitive. */ if (value === null) { return 'null'; } /* Handle the rest of the primitives and functions. */ switch (typeof value) { case 'number': if (Number.isNaN(value)) { return 'NaN'; } else if (!Number.isFinite(value)) { return 'Infinity'; } case 'boolean': case 'symbol': case 'undefined': return String(value); case 'string': return JSON.stringify(value); case 'function': return 'Function'; } const objType = Util.toStringTag(value); /* Handle `Date` objects. */ if (objType === 'Date') { return `Date\u202F{${value.toLocaleString()}}`; } /* Handle `RegExp` objects. */ if (objType === 'RegExp') { return `RegExp\u202F${value.toString()}`; } const result = []; /* Handle `Array` & `Set` objects. */ if (value instanceof Array || value instanceof Set) { const list = value instanceof Array ? value : Array.from(value); for (let i = 0, len = list.length; i < len; ++i) { result.push(list.hasOwnProperty(i) ? _toWatchString(list[i]) : '<empty>'); } Object.keys(list) .filter(key => !_numericKeyRe.test(key)) .forEach(key => result.push(`${_toWatchString(key)}: ${_toWatchString(list[key])}`)); return `${objType}(${list.length})\u202F[${result.join(', ')}]`; } /* Handle `Map` objects. */ if (value instanceof Map) { value.forEach((val, key) => result.push(`${_toWatchString(key)} \u2192 ${_toWatchString(val)}`)); return `${objType}(${value.size})\u202F{${result.join(', ')}}`; } /* General object handling. */ Object.keys(value) .forEach(key => result.push(`${_toWatchString(key)}: ${_toWatchString(value[key])}`)); return `${objType}\u202F{${result.join(', ')}}`; } /******************************************************************************************************************* Module Exports. *******************************************************************************************************************/ return Object.freeze(Object.defineProperties({}, { /* Debug Bar Functions. */ init : { value : debugBarInit }, isStowed : { value : debugBarIsStowed }, start : { value : debugBarStart }, stow : { value : debugBarStow }, toggle : { value : debugBarToggle }, unstow : { value : debugBarUnstow }, /* Watch Functions. */ watch : { value : Object.freeze(Object.defineProperties({}, { add : { value : debugBarWatchAdd }, all : { value : debugBarWatchAddAll }, clear : { value : debugBarWatchClear }, delete : { value : debugBarWatchDelete }, disable : { value : debugBarWatchDisable }, enable : { value : debugBarWatchEnable }, isEnabled : { value : debugBarWatchIsEnabled }, toggle : { value : debugBarWatchToggle } })) } })); })(); /*********************************************************************************************************************** loadscreen.js Copyright © 2013–2021 Thomas Michael Edwards <thomasmedwards@gmail.com>. All rights reserved. Use of this source code is governed by a BSD 2-clause "Simplified" License, which may be found in the LICENSE file. ***********************************************************************************************************************/ var LoadScreen = (() => { 'use strict'; const _locks = new Set(); let _autoId = 0; /******************************************************************************************************************* LoadScreen Functions. *******************************************************************************************************************/ /* Initialize management of the loading screen. */ function loadScreenInit() { if (DEBUG) { console.log('[LoadScreen/loadScreenInit()]'); } jQuery(document).on('readystatechange.SugarCube', () => { if (DEBUG) { console.log(`[LoadScreen/<readystatechange>] document.readyState: "${document.readyState}"; locks(${_locks.size}):`, _locks); } if (_locks.size > 0) { return; } if (document.readyState === 'complete') { if (jQuery(document.documentElement).attr('data-init') === 'loading') { if (Config.loadDelay > 0) { setTimeout(() => { if (_locks.size === 0) { loadScreenHide(); } }, Math.max(Engine.minDomActionDelay, Config.loadDelay)); } else { loadScreenHide(); } } } else { loadScreenShow(); } }); } /* Clear the loading screen. */ function loadScreenClear() { if (DEBUG) { console.log('[LoadScreen/loadScreenClear()]'); } jQuery(document).off('readystatechange.SugarCube'); _locks.clear(); loadScreenHide(); } /* Hide the loading screen. */ function loadScreenHide() { if (DEBUG) { console.log('[LoadScreen/loadScreenHide()]'); } jQuery(document.documentElement).removeAttr('data-init'); } /* Show the loading screen. */ function loadScreenShow() { if (DEBUG) { console.log('[LoadScreen/loadScreenShow()]'); } jQuery(document.documentElement).attr('data-init', 'loading'); } /* Returns a new lock ID after locking and showing the loading screen. */ function loadScreenLock() { if (DEBUG) { console.log('[LoadScreen/loadScreenLock()]'); } ++_autoId; _locks.add(_autoId); if (DEBUG) { console.log(`\tacquired loading screen lock; id: ${_autoId}`); } loadScreenShow(); return _autoId; } /* Remove the lock associated with the given lock ID and, if no locks remain, trigger a `readystatechange` event. */ function loadScreenUnlock(id) { if (DEBUG) { console.log(`[LoadScreen/loadScreenUnlock(id: ${id})]`); } if (id == null) { throw new Error('LoadScreen.unlock called with a null or undefined ID'); } if (_locks.has(id)) { _locks.delete(id); if (DEBUG) { console.log(`\treleased loading screen lock; id: ${id}`); } } if (_locks.size === 0) { jQuery(document).trigger('readystatechange'); } } /******************************************************************************************************************* Module Exports. *******************************************************************************************************************/ return Object.freeze(Object.defineProperties({}, { init : { value : loadScreenInit }, clear : { value : loadScreenClear }, hide : { value : loadScreenHide }, show : { value : loadScreenShow }, lock : { value : loadScreenLock }, unlock : { value : loadScreenUnlock } })); })(); /* * "simple" indexedDB backend for storing save data, working similarly to existing webStorage system * indexedDB works faster, has virtually unlimited storage, but does not work properly in private mode. then again, localStorage doesn't persist in private mode either * indexedDB operates asynchronously, by making requests that may be fulfilled or rejected later, without blocking the rest of the code, but also without a guarantee that requested values will be available when that rest of the code runs. this requires some working around. * unlike old synchronous operations, most functions do not return the value immediately, but a promise to return it when it's completed. these promises can then be used to retrieve that data by calling Promise.then() callback function * for example, `idb.getItem(0).then((value) => console.log(value))` will first attempt to retrieve save data from slot 0, and then when that is done - the then() function triggers, in this case printing retrieved value to the console * * this implementation doesn't rely on caches, doesn't compress save data in any way, and separates save details store from save data store to speed up building the save list and allow extra features like timestamp highlighting at minimal processing cost * as a consequence, it requires more disk space, and a completely separate namespace that might need extra setup for games that override the default save list appearance * generally though, just adding a "saveList" id or class to the div element where the saves should appear and replacing the function/macro that populates that div with "if (idb.active) idb.saveList(); else old-custom-way-of-building-save-menu" should be enough to make it work. */ const idb = (() => { "use strict"; if (window.indexedDB == null) return Object.freeze({ lock: true, init() { return false; }, get active() { return false; }, set active(_) { return false; }, get footerHTML() { return false; }, set footerHTML(_) { return false; }, }); let _lock = true; let _active = true; let _dbName = "idb"; let _migrationNeeded = false; let _settings = {}; updateSettings(); let _saveDetails = []; function log(description, data, useClone) { console.log(description, useClone ? clone(data) : data); if (window.Errors) Errors.report(description, data, useClone); else alert(`${description}\n${JSON.stringify(data)}`); } const _version = 1; function dbUpgrade(ev) { const db = ev.target.result; const ver = ev.oldVersion; console.log("updating idb", ver); switch (ver) { case 0: db.createObjectStore("saves", { keyPath: "slot" }); db.createObjectStore("details", { keyPath: "slot" }); _migrationNeeded = true; break; case 1: } } function openDB(name = _dbName, version = _version) { return new Promise((resolve, reject) => { _dbName = name; const openRequest = indexedDB.open(idb.dbName, version); openRequest.onupgradeneeded = dbUpgrade; openRequest.onerror = ev => { const err = ev.target.error; log("error opening idb", err); reject(err); }; openRequest.onsuccess = ev => { _lock = false; if (navigator.storage && typeof navigator.storage.persist === "function") navigator.storage.persist(); const db = ev.target; db.onclose = ev => { _active = false; log("ERROR: idb connection closed unexpectedly", ev); }; db.onerror = ev => { _active = false; log("Database error", ev.target.errorCode); }; if (_migrationNeeded) { importFromLocalStorage(); _migrationNeeded = false; } resolve(db.result); }; openRequest.onblocked = () => { console.log("something went wrong", openRequest.error); }; }); } /** * synchronize internal settings with persistent storage * allowing them to survive page reload * * @param {string} setting accessor to modify * @param {boolean} value to set */ function updateSettings(setting, value) { const storageName = "idb-settings"; _settings = JSON.parse(localStorage.getItem(storageName)) || { warnSave: V.confirmSave || false, warnLoad: V.confirmLoad || false, warnDelete: V.confirmDelete || true, active: !window.FCHostPersistent, useDelta: true, }; _active = _settings.active; if (!setting) return; if (!['warnSave', 'warnLoad', 'warnDelete', 'active', 'useDelta'].includes(setting)) return console.warn(`idbupdatesettings: invalid argument: ${setting}`); if (value == null) return _settings[setting]; _settings[setting] = value; _active = _settings.active; localStorage.setItem(storageName, JSON.stringify(_settings)); } updateSettings(); const baddies = []; /** * scan and stringify functions that wormed their way into story vars * and other objects with custom toJSON revivals * * @param {object} target to scan * @param {object} path to report * @param {boolean} verbose flag to report objects too complex for idb */ function funNuke(target, path = "", verbose = true) { if (!target) return console.log("no target specified"); for (const key in target) { const value = target[key]; const newPath = `${path}['${key}']`; if (value == null) continue; else if (typeof value === "function" || value.toJSON) { if (verbose && V.idbTest) { console.log(`Warn: ${newPath} of type ${typeof value} shouldn't be in STORY variables!!!`); } target[key] = JSON.stringify(value); baddies.push(newPath); } else if (typeof value === "object") funNuke(value, newPath, verbose); } } /** * restore nuked functions and other nasty stuff * * @param {object} target store to alter * @param {array} paths to restore */ function ekuNnuf(target = V, paths) { /** * sub-function to revive specified path * * @param {object} target * @param {string} path string in a format "['path']['to']['object']" * @returns true on success */ function revive(target, path) { if (typeof path !== "string" || path === "") return console.log("Warn: invalid path", clone(path)); const accessors = path.slice(2,-2).split("']['"); let ref = target; for (let i = 0, destination = accessors.length - 1; i <= destination; i++) { if (i === destination) ref[accessors[i]] = JSON.parse(ref[accessors[i]]); else ref = ref[accessors[i]]; } return true; } let path = ""; while (path = paths.shift()) { try { revive(target, path); } catch (ex) { console.log("WARN: couldn't restore story var function", path); } } } /** * copy saves from localStorage into indexedDB, without regard for what's already in there * * @returns {boolean} success of the operation */ async function importFromLocalStorage() { function processSave(fullSaveObj) { const save = fullSaveObj.state; if (save.jdelta) delete save.jdelta; if (save.delta) save.history = State.deltaDecode(save.delta); delete save.delta; if (window.DoLSave) DoLSave.decompressIfNeeded({ state: save }); const vars = save.history[save.index].variables; if (!vars.saveId) { const saveId = Math.floor(Math.random() * 90000) + 10000; save.history.forEach(s => s.variables.saveId = saveId); } const details = { date: fullSaveObj.date, id: fullSaveObj.id, idx: fullSaveObj.idx, title: fullSaveObj.title, metadata: fullSaveObj.metadata || { saveId: vars.saveId, saveName: vars.saveName }, }; return [save, details]; } let mtCount = 0; const oldSaves = Save.get(); const autoSave = oldSaves.autosave; if (autoSave != null) { const saveData = processSave(save); await setItem(0, saveData[0], { slot: 0, data: saveData[1] }); } else mtCount++; for (let i = 0; i < oldSaves.slots.length; i++) { const slotSave = oldSaves.slots[i]; if (slotSave != null) { const saveData = processSave(slotSave); await setItem(i + 1, saveData[0], { slot: i + 1, data: saveData[1] }); } else mtCount++; } if (mtCount === oldSaves.slots.length + 1) { const index = storage.get("index"); if (index && index.slots) { const autosave = storage.get("autosave"); if (autosave) { const saveData = processSave(autosave); await setItem(0, saveData[0], { slot: 0, data: saveData[1] }); } for (let i = 0; i < index.slots.length; i++) { const slotSave = storage.get("slot" + i); if (!slotSave) continue; const saveData = processSave(slotSave); await setItem(i + 1, saveData[0], { slot: i + 1, data: saveData[1] }); } } } await getSaveDetails().then(d => _saveDetails = d); console.log("idb migration successful"); return true; } /** * turn transaction event handlers into promises * * @param {Request} transaction */ function makePromise(transaction) { return new Promise((resolve, reject) => { transaction.onsuccess = () => { _lock = false; return resolve(transaction.result); }; transaction.oncomplete = () => { _lock = false; return resolve(transaction.result); }; transaction.onerror = ev => { _lock = false; _active = false; console.log(transaction.error, ev, "error"); return reject(transaction.error); }; transaction.onabort = () => { _lock = false; console.log("aborted", transaction.error); return reject(transaction.error); }; }); } /** * retrieve an item from indexedDB * * @param {number} slot * @returns {Promise} promise to return a value some day */ async function getItem(slot) { const db = await openDB(); const transactionRequest = db.transaction("saves", "readonly"); const item = transactionRequest.objectStore("saves").get(slot); const result = await makePromise(item).catch(err => log(`couldn't retrieve idb item in slot ${slot}`, err)); db.close(); return result; } /** * place a save object into saves store and a provided or calculated details object into details store * will replace existing object in specified slot without a second thought * * @param {number} slot slot to write into * @param {object} saveObj valid save object with unencoded history * @param {object} details optional save details to override what's going into details store * @returns {Promise | undefined} promise to report on success of this operation some day or return early */ async function setItem(slot, saveObj, details) { if (_lock) return; if (saveObj == null || !Object.hasOwn(saveObj, "history")) return false; _lock = true; const savesItem = { slot, data: saveObj }; const saveVars = saveObj.history[saveObj.index].variables; const metadata = Object.assign({ saveId: saveVars.saveId, saveName: saveVars.saveName }, details?.metadata); details.metadata = metadata; const detailsItem = details ? { slot, data: details, } : { slot, data: { id: Story.domId, idx: State.qc, title: Story.get(State.passage).description(), date: Date.now(), metadata, }, }; try { let counter = 0; saveObj.history.forEach(s => { baddies.splice(0); funNuke(s.variables, "", !counter++); if (baddies.length) s.baddies = clone(baddies); }); if (_settings.useDelta && slot !== 0) { saveObj.delta = State.deltaEncode(saveObj.history); delete saveObj.history; } const db = await openDB(); const transactionRequest = db.transaction(["saves", "details"], "readwrite"); transactionRequest.objectStore("saves").delete(slot); transactionRequest.objectStore("saves").add(savesItem); transactionRequest.objectStore("details").delete(slot); transactionRequest.objectStore("details").add(detailsItem); const result = await makePromise(transactionRequest).catch(err => log(`couldn't put idb item in slot ${slot}`, err)); db.close(); return result; } catch (ex) { log(`idb.setItem failure unknown. Couldn't complete the save in slot ${slot}`); _lock = false; return new Promise(resolve => resolve(false)); } } /** * delete save data in a specified slot * * @param {number} slot * @returns {Promise | undefined} promise to report on success or return early */ async function deleteItem(slot) { if (_lock) return; const db = await openDB(); _lock = true; const transactionRequest = db.transaction(["saves", "details"], "readwrite"); transactionRequest.objectStore("saves").delete(slot); transactionRequest.objectStore("details").delete(slot); const result = await makePromise(transactionRequest); db.close(); await getSaveDetails(); return result; } /** * actually load a save from idb * * @param {number} slot */ async function loadState(slot) { if (_lock) return; const data = await getItem(slot); if (data == null) return false; const state = data.data; if (state.delta) { state.history = State.deltaDecode(state.delta); delete state.delta; } state.history.forEach(s => { if (s.baddies) { ekuNnuf(s.variables, s.baddies); delete s.baddies; } }); const details = _saveDetails.find(d => d.slot === slot)?.data; state.idx = details.idx; const fullSaveObj = Object.assign({ state }, details); Save.onLoad.handlers.forEach(fn => fn(fullSaveObj)); State.unmarshalForSave(state); State.show(); } /** * save current game into idb * * @param {number} slot * @param {string} title * @param {object} metadata */ async function saveState(slot, title, metadata) { if (_lock) return; if (!V.saveId) { const saveId = Math.floor(Math.random() * 90000) + 10000; V.saveId = saveId; State.history.forEach(s => s.variables.saveId = saveId); } const saveObj = State.marshalForSave(); const fullSaveObj = { state: saveObj, date: Date.now(), id: Story.domId, idx: State.qc, title: title || Story.get(State.passage).description(), }; if (metadata != null) fullSaveObj.metadata = metadata; Save.onSave.handlers.forEach(fn => fn(fullSaveObj, { type: slot <= 0 ? "autosave" : "slot" })); const details = fullSaveObj; delete details.state; if (saveObj != null) { await setItem(slot, saveObj, details); await getSaveDetails(); return true; } return false; } /** * retrieve details for all saves from idb and also cache them to _saveDetails for fast retrieval * * @returns {Promise<array>} list of details for all saves in idb */ async function getSaveDetails() { const db = await openDB(); const transactionRequest = db.transaction(["details"], "readonly"); const details = await makePromise(transactionRequest.objectStore("details").getAll()); db.close(); _saveDetails = details; return details; } /** * get DATA for ALL saves in the db * WILL fail if db is bigger than 2gb (and probably earlier) * * @returns {Array} list of data for all saves in idb */ async function getAllSaves() { const db = await openDB(); const transactionRequest = db.transaction(["saves"], "readonly"); const saves = transactionRequest.objectStore("saves").getAll(); const result = await makePromise(saves) db.close(); return result; } /** * mercilessly clear all object stores one step short from outright deleting the db itself * * @returns {Promise | undefined} promise to maybe report when the deed is done or return early */ async function clearAll() { if (_lock) return; const db = await openDB(); const transactionRequest = db.transaction(["saves", "details"], "readwrite"); transactionRequest.objectStore("saves").clear(); transactionRequest.objectStore("details").clear(); _saveDetails = []; return makePromise(transactionRequest); } /** * check if saves are allowed */ function savesAllowed() { return typeof Config.saves.isAllowed !== "function" || Config.saves.isAllowed(); } /** * define saveList variables */ let listLength; let listPage; const listLengthMax = 20; const listPageMax = 20; let latestSave = { slot: 1, date: 0 }; let extraSaveWarn; let footerHTML = ""; /** * construct a saves list page, with configurable length * * @param {number} page * @param {number} length * @returns {DocumentFragment}; */ function generateSavesPage(page = listPage - 1, length = listLength) { const listContainer = document.createElement("div"); listContainer.id = "saves-list-container"; listContainer.appendChild(generateHeaderRow()); const saveUnlock = savesAllowed(); latestSave = { slot: 1, date: 0 }; let autoSaveDate; _saveDetails.forEach(d => { if (d.slot === 0) autoSaveDate = d.data.date; else if (d.data.date > latestSave.date) { latestSave.slot = d.slot; latestSave.date = d.data.date; } }); if (!listLength) { const slot = _saveDetails.length ? _saveDetails.last().slot : 0; for (listLength = 10; slot > listLength * listPageMax && listLength < listLengthMax; listLength++); length = listLength; } if (!Number.isInteger(page)) { const latestSlot = _saveDetails.find(d => d.slot === latestSave.slot); if (latestSlot) { const autoSaveExists = Boolean(_saveDetails.find(d => d.slot === 0)); const ignoreAutoSave = latestSlot.data.date > autoSaveDate || latestSlot.data.metadata.saveId === _saveDetails[0].data.metadata.saveId; if (!autoSaveExists || ignoreAutoSave) page = Math.floor((latestSave.slot - 1) / length); else page = 0; } else page = 0; listPage = page + 1; } const pageField = document.getElementById("pageNum"); if (pageField != null) pageField.value = listPage; const lengthField = document.getElementById("pageLen"); if (lengthField != null) lengthField.value = listLength; const defaultDetailsObj = { date: "", title: "", metadata: { saveId: "", saveName: "" } }; const autoDetailsObj = _saveDetails.find(d => d.slot === 0)?.data ?? clone(defaultDetailsObj); if (autoSaveDate > latestSave.date) autoDetailsObj.latestSlot = true; autoDetailsObj.slot = 0; if (Save.autosave.ok()) listContainer.appendChild(generateSaveRow(autoDetailsObj)); for (let slot = length * page + 1; slot < length * (page + 1) + 1; slot++) { let detailsObj = clone(defaultDetailsObj); const detailsIndex = _saveDetails.findIndex(d => d.slot === slot); if (detailsIndex !== -1) { detailsObj = _saveDetails[detailsIndex].data; if (Number(latestSave.slot) === slot) detailsObj.latestSlot = true; } detailsObj.slot = slot; detailsObj.saveUnlock = saveUnlock; listContainer.appendChild(generateSaveRow(detailsObj)); } return listContainer; } /** * construct the header row for the save list * warning: unnecessarily complicated DOM manipulations * * @returns {DocumentFragment} header row */ function generateHeaderRow() { const frag = document.createDocumentFragment(); const saveListHeader = document.createElement("div"); saveListHeader.className = "savesListRow"; frag.appendChild(saveListHeader); const headerSaveGroup = document.createElement("div"); headerSaveGroup.className = "saveGroup"; saveListHeader.appendChild(headerSaveGroup); const headerSaveId = document.createElement("div"); headerSaveId.className = "saveId"; headerSaveId.innerText = "#"; headerSaveGroup.appendChild(headerSaveId); const headerSaveButton = document.createElement("div"); headerSaveButton.className = "saveButton"; headerSaveButton.innerText = L10n.get("savesHeaderSaveLoad"); headerSaveGroup.appendChild(headerSaveButton); const headerSaveName = document.createElement("div"); headerSaveName.className = "saveName"; headerSaveName.innerText = L10n.get("savesHeaderIDName"); headerSaveGroup.appendChild(headerSaveName); const headerSaveDetails = document.createElement("div"); headerSaveDetails.className = "saveDetails"; headerSaveDetails.innerText = L10n.get("savesHeaderDetails"); headerSaveGroup.appendChild(headerSaveDetails); const headerDeleteButton = document.createElement("div"); headerDeleteButton.className = "deleteButton"; headerSaveGroup.appendChild(headerDeleteButton); return frag; } /** * construct the footer row for the save list * warning: unnecessarily complicated DOM manipulations * * @returns {HTMLUListElement} footer row */ function generateFooterRow() { const container = document.createElement("ul"); container.className = "buttons"; let li; const exportButton = document.createElement("button"); exportButton.id = "saves-export"; exportButton.className = "ui-close"; exportButton.innerText = L10n.get("savesLabelExport"); if (savesAllowed()) { exportButton.onclick = () => Save.export(); exportButton.classList.add("saveMenuButton"); } else exportButton.disabled = true; li = document.createElement("li"); li.appendChild(exportButton); container.appendChild(li); if (navigator.clipboard) { const toClipboardButton = document.createElement("button"); toClipboardButton.id = "saves-toClipboard"; toClipboardButton.className = "ui-close"; toClipboardButton.innerText = L10n.get("savesLabelToClipboard"); if (savesAllowed()) { toClipboardButton.onclick = () => { navigator.clipboard.writeText(Save.serialize()); window.closeOverlay(); }; toClipboardButton.classList.add("saveMenuButton"); } else toClipboardButton.disabled = true; li = document.createElement("li"); li.appendChild(toClipboardButton); container.appendChild(li); } const importButton = document.createElement("button"); importButton.id = "saves-import"; importButton.className = "saveMenuButton"; importButton.innerText = L10n.get("savesLabelImport"); importButton.onclick = () => { jQuery(document.createElement("input")).prop("type", "file").on("change", SugarCube.Save.import).trigger("click"); window.closeOverlay(); }; li = document.createElement("li"); li.appendChild(importButton); container.appendChild(li); const clearAllButton = document.createElement("button"); clearAllButton.className = "saves-clear saveMenuButton"; clearAllButton.innerText = L10n.get("savesLabelClear"); clearAllButton.onclick = () => saveList("confirm clear"); li = document.createElement("li"); li.appendChild(clearAllButton); container.appendChild(li); return container; } /** * optional extra footer row */ function generateExtraFooterRow() { if (!footerHTML) return null; const container = document.createElement("ul"); container.className = "buttons"; container.innerHTML = footerHTML; return container; } /** * all this to generate a single saves row from provided details * pure js dom manipulations are ugly * * @param {object} details save details * @returns {DocumentFragment} */ function generateSaveRow(details) { const row = document.createElement("div"); if (details.latestSlot && details.slot !== 0) row.id = "latestSaveRow"; row.className = "savesListRow"; const group = document.createElement("div"); group.className = "saveGroup"; const saveId = document.createElement("div"); saveId.className = "saveId"; saveId.innerText = details.slot === 0 ? "A" : details.slot; if (details.slot > listPageMax * listLengthMax || details.slot < 0) saveId.classList.add("red"); const saveload = document.createElement("div"); saveload.className = "saveButton"; const saveButton = document.createElement("button"); saveButton.innerText = L10n.get("savesLabelSave"); if (details.saveUnlock) { saveButton.className = "saveMenuButton"; saveButton.onclick = () => saveList("confirm save", details); } else { saveButton.disabled = true; } const loadButton = document.createElement("button"); loadButton.innerText = L10n.get("savesLabelLoad"); if (details.date) { loadButton.className = "saveMenuButton"; loadButton.onclick = () => saveList("confirm load", details); } else { loadButton.disabled = true; } if (details.slot !== 0) saveload.appendChild(saveButton); saveload.appendChild(loadButton); const saveName = document.createElement("div"); saveName.className = "saveName"; if (V.saveId === details.metadata.saveId) saveName.classList.add("gold"); saveName.innerText = details.metadata.saveName ? details.metadata.saveName.slice(0, 10) : details.metadata.saveId; const saveDetails = document.createElement("div"); saveDetails.className = "saveDetails"; const description = document.createElement("span"); description.innerText = details.title || "\xa0"; const date = document.createElement("span"); date.className = "datestamp"; if (details.date) { if (details.latestSlot) date.classList.add("green"); else if (details.date > Date.now() - 1800000) date.classList.add("gold"); date.innerText = new Date(details.date).toLocaleString(); } else date.innerText = "\xa0"; saveDetails.appendChild(description); saveDetails.appendChild(date); const deleteButton = document.createElement("button"); deleteButton.className = "deleteButton right"; deleteButton.innerText = L10n.get("savesLabelDelete"); if (details.date) { deleteButton.classList.add("saveMenuButton"); deleteButton.onclick = () => saveList("confirm delete", details); } else { deleteButton.disabled = true; } group.append(saveId, saveload, saveName, saveDetails); row.appendChild(group); row.appendChild(deleteButton); return row; } /** * @returns {HTMLUListElement} */ function generatePager() { const container = document.createElement("ul"); container.className = "buttons"; let li; li = document.createElement("li"); li.append(L10n.get("savesPagerPage")); container.appendChild(li); const prevPage = document.createElement("button"); prevPage.append("<"); if (listPage > 1) { prevPage.classList.add("saveMenuButton"); prevPage.onclick = () => { --listPage; saveList("show saves"); }; } else prevPage.disabled = true; li = document.createElement("li"); li.appendChild(prevPage); container.appendChild(li); const pageNum = document.createElement("input"); Object.assign(pageNum, { id: "pageNum", type: "number", value: listPage, style: "width: 3em", min: 1, max: listPageMax, onchange: () => { listPage = Math.clamp(Math.round(pageNum.value), 1, listPageMax); saveList("show saves"); }, }); container.appendChild(pageNum); const nextPage = document.createElement("button"); nextPage.append(">"); if (listPage < listPageMax) { nextPage.classList.add("saveMenuButton"); nextPage.onclick = () => { ++listPage; saveList("show saves"); }; } else nextPage.disabled = true; nextPage.onclick = () => { if (listPage < listPageMax) listPage++; saveList("show saves"); }; li = document.createElement("li"); li.appendChild(nextPage); container.appendChild(li); li = document.createElement("li"); li.append(L10n.get("savesPagerSavesPerPage")); container.appendChild(li); const pageLen = document.createElement("input"); Object.assign(pageLen, { id: "pageLen", type: "number", value: listLength, style: "width: 3em", min: 1, max: listLengthMax, onchange: () => { listLength = Math.clamp(pageLen.value, 1, listLengthMax); saveList("show saves"); }, }); li = document.createElement("li"); li.append(pageLen); container.appendChild(li); const jumpToLatest = document.createElement("button"); jumpToLatest.className = "saveMenuButton"; jumpToLatest.innerText = L10n.get("savesPagerJump"); jumpToLatest.onclick = () => { listPage = Math.floor((latestSave.slot - 1) / listLength + 1); saveList("show saves"); setTimeout(() => { const el = document.getElementById("latestSaveRow"); if (el != null) { el.classList.remove("jumpToSaveTransition"); el.classList.add("jumpToSaveTransition"); } }, Engine.minDomActionDelay + 100); }; li = document.createElement("li"); li.appendChild(jumpToLatest); container.appendChild(li); return container; } const replaceChildren = !!document.body.replaceChildren; if (typeof window.closeOverlay === "undefined") window.closeOverlay = Dialog.close; /** * replace contents of saveList div with something useful * * @param {string} mode switch for displaying saves list or confirmations * @param {object} details save details for confirmations */ async function saveList(mode, details) { if (_active && !_settings.active) updateSettings("active", true); if (!mode) { await getSaveDetails(); mode = "show saves"; } await new Promise(r => setTimeout(() => r(true), 0)); const savesDiv = document.getElementById("saveList") || document.getElementsByClassName("saveList")[0] || document.getElementsByClassName("saves")[0]; const list = document.createDocumentFragment(); const cancelButton = document.createElement("button"); cancelButton.className = "saveMenuButton saveMenuConfirm"; cancelButton.innerText = L10n.get("cancel"); cancelButton.onclick = () => saveList("show saves"); function generateOldSaveDescription(details) { const oldSaveDescription = document.createDocumentFragment(); if (!details || !details.date) return oldSaveDescription; const oldSaveTitle = document.createElement("p"); oldSaveTitle.innerText = `${L10n.get("savesDescTitle")} ${details.title}`; const oldSaveData = document.createElement("p"); oldSaveData.innerText = `${details.metadata.saveName ? L10n.get("savesDescName") + details.metadata.saveName : L10n.get("savesDescId") + details.metadata.saveId} ${L10n.get("savesDescDate")} ${new Date(details.date).toLocaleString()}`; oldSaveDescription.append(oldSaveTitle, oldSaveData); return oldSaveDescription; } switch (mode) { case "show saves": { if (!savesAllowed()) { const notAllowedWarning = document.createElement("h3"); notAllowedWarning.className = "red"; notAllowedWarning.innerText = V.replayScene ? L10n.get("savesDisallowedReplay") : L10n.get("savesDisallowed"); list.appendChild(notAllowedWarning); } const exportReminder = document.createElement("p"); exportReminder.id = "saves-export-reminder"; exportReminder.innerText = L10n.get("savesExportReminder"); list.appendChild(exportReminder); if (extraSaveWarn) { const lostSaves = document.createElement("p"); lostSaves.innerHTML = "<i class=\"description\"><u>Where are my saves?</u></i> "; const lostSavesTooltip = document.createElement("mouse"); lostSavesTooltip.classList.add("tooltip", "linkBlue"); lostSavesTooltip.innerText = "(?)"; lostSavesTooltip.appendChild(document.createElement("span")); lostSavesTooltip.lastChild.innerText = "If you can't find your saves, it's possible you saved them using a different storage method. Try toggling the \"Use old legacy storage\" option below the saves list."; lostSaves.appendChild(lostSavesTooltip); list.appendChild(lostSaves); } list.appendChild(generateSavesPage()); list.appendChild(generateFooterRow()); if (footerHTML) list.appendChild(generateExtraFooterRow()); list.appendChild(generatePager()); let ul = document.createElement("ul"); ul.className = "buttons"; let li; li = document.createElement("li"); li.append(L10n.get("savesOptionsConfirmOn")); ul.appendChild(li); const reqSaveLabel = document.createElement("label"); reqSaveLabel.innerText = L10n.get("savesOptionsOverwrite"); const reqSave = document.createElement("input"); reqSave.type = "checkbox"; reqSave.checked = _settings.warnSave; reqSave.onchange = () => updateSettings("warnSave", reqSave.checked); reqSaveLabel.appendChild(reqSave); li = document.createElement("li"); li.appendChild(reqSaveLabel); ul.appendChild(li); const reqLoadLabel = document.createElement("label"); reqLoadLabel.innerText = L10n.get("savesLabelLoad"); const reqLoad = document.createElement("input"); reqLoad.type = "checkbox"; reqLoad.checked = _settings.warnLoad; reqLoad.onchange = () => updateSettings("warnLoad", reqLoad.checked); reqLoadLabel.appendChild(reqLoad); li = document.createElement("li"); li.appendChild(reqLoadLabel); ul.append("|", li); const reqDeleteLabel = document.createElement("label"); reqDeleteLabel.innerText = L10n.get("savesLabelDelete"); const reqDelete = document.createElement("input"); reqDelete.type = "checkbox"; reqDelete.checked = _settings.warnDelete; reqDelete.onchange = () => updateSettings("warnDelete", reqDelete.checked); reqDeleteLabel.appendChild(reqDelete); li = document.createElement("li"); li.appendChild(reqDeleteLabel); ul.append("|", li); ul.append(document.createElement("li")); list.append(ul); ul = document.createElement("ul"); ul.className = "buttons"; const idbtoggle = document.createElement("button"); idbtoggle.id = "saves-idb-toggle"; idbtoggle.className = "saveMenuButton"; idbtoggle.innerText = L10n.get("savesOptionsUseLegacy"); idbtoggle.onclick = () => { updateSettings("active", false); if (window.DoLSave) $.wiki("<<replace #saveList>><<saveList>><</replace>>"); else UI.buildSaves(); }; li = document.createElement("li"); li.appendChild(idbtoggle); ul.appendChild(li); list.appendChild(ul); setTimeout(() => { if (replaceChildren) savesDiv.replaceChildren(list); else { savesDiv.innerHTML = ""; savesDiv.appendChild(list); } const pageField = document.getElementById("pageNum"); if (pageField != null) pageField.value = listPage; const lengthField = document.getElementById("pageLen"); if (lengthField != null) lengthField.value = listLength; Dialog.resize(); }, Engine.minDomActionDelay); break; } case "confirm save": { if (!details.date || !_settings.warnSave && details.metadata.saveId === V.saveId) return saveState(details.slot).then(window.closeOverlay()); const confirmSaveWarning = document.createElement("div"); confirmSaveWarning.className = "saveBorder"; const confirmSaveWarningTitle = document.createElement("h3"); confirmSaveWarningTitle.className = "red"; confirmSaveWarningTitle.innerText = `${details.date === "" ? L10n.get("savesWarningSaveOnSlot") : L10n.get("savesWarningOverwriteSlot")} ${details.slot}?`; if (details.date && V.saveId !== details.metadata.saveId) { const overwriteWarning = document.createElement("span"); overwriteWarning.className = "red"; overwriteWarning.innerText = L10n.get("savesWarningOverwriteID"); } const saveButton = document.createElement("input"); Object.assign(saveButton, { type: "button", className: "saveMenuButton saveMenuConfirm", value: L10n.get("savesLabelSave"), onclick: () => saveState(details.slot).then(() => window.closeOverlay()), }); confirmSaveWarning.append(confirmSaveWarningTitle, generateOldSaveDescription(details), saveButton, cancelButton); list.appendChild(confirmSaveWarning); setTimeout(() => { if (replaceChildren) savesDiv.replaceChildren(list); else { savesDiv.innerHTML = ""; savesDiv.appendChild(list); } }, Engine.minDomActionDelay); break; } case "confirm delete": { if (!_settings.warnDelete) return deleteItem(details.slot).then(() => saveList("show saves")); const confirmDeleteWarning = document.createElement("div"); confirmDeleteWarning.className = "saveBorder"; const confirmDeleteWarningTitle = document.createElement("h3"); confirmDeleteWarningTitle.className = "red"; confirmDeleteWarningTitle.innerText = `${L10n.get("savesWarningDeleteInSlot") + (details.slot === 0 ? "auto" : details.slot)}?`; const deleteButton = document.createElement("input"); Object.assign(deleteButton, { type: "button", className: "saveMenuButton saveMenuConfirm", value: L10n.get("savesLabelDelete"), onclick: () => deleteItem(details.slot).then(() => saveList("show saves")), }); confirmDeleteWarning.append(confirmDeleteWarningTitle, generateOldSaveDescription(details), deleteButton, cancelButton); list.appendChild(confirmDeleteWarning); setTimeout(() => { if (replaceChildren) savesDiv.replaceChildren(list); else { savesDiv.innerHTML = ""; savesDiv.appendChild(list); } }, Engine.minDomActionDelay); break; } case "confirm load": { if (!_settings.warnLoad) return loadState(details.slot).then(() => window.closeOverlay()); const confirmLoad = document.createElement("div"); confirmLoad.className = "saveBorder"; const confirmLoadTitle = document.createElement("h3"); confirmLoadTitle.className = "red"; confirmLoadTitle.innerText = `${L10n.get("savesWarningLoad") + (details.slot === 0 ? "auto" : details.slot)}?`; const loadButton = document.createElement("input"); Object.assign(loadButton, { type: "button", className: "saveMenuButton saveMenuConfirm", value: L10n.get("savesLabelLoad"), onclick: () => idb.loadState(details.slot).then(() => window.closeOverlay()), }); confirmLoad.append(confirmLoadTitle, generateOldSaveDescription(details), loadButton, cancelButton); list.appendChild(confirmLoad); setTimeout(() => { if (replaceChildren) savesDiv.replaceChildren(list); else { savesDiv.innerHTML = ""; savesDiv.appendChild(list); } }, Engine.minDomActionDelay); break; } case "confirm clear": { const confirmClear = document.createElement("div"); confirmClear.className = "saveBorder"; const confirmClearTitle = document.createElement("h2"); confirmClearTitle.className = "red"; confirmClearTitle.innerText = L10n.get("savesWarningDeleteAll"); const clearButton = document.createElement("input"); Object.assign(clearButton, { type: "button", className: "saveMenuButton saveMenuConfirm", value: L10n.get("savesLabelClear"), onclick: () => clearAll().then(() => saveList("show saves")), }); confirmClear.append(confirmClearTitle, clearButton, cancelButton); list.appendChild(confirmClear); setTimeout(() => { if (replaceChildren) savesDiv.replaceChildren(list); else { savesDiv.innerHTML = ""; savesDiv.appendChild(list); } }, Engine.minDomActionDelay); break; } } } return Object.freeze(Object.defineProperties({}, { dbName: { get() { return _dbName; }, set(val) { _dbName = val; } }, lock: { get() { return _lock; }, set(val) { _lock = Boolean(val); } }, active: { get() { return _active; }, set(val) { _active = Boolean(val); } }, listLength: { get() { return listLength; }, set(val) { listLength = val; } }, listPage: { get() { return listPage; }, set(val) { listPage = val; } }, footerHTML: { get() { return footerHTML; }, set(val) { footerHTML = val; } }, baddies: { get() { return baddies; } }, init: { value(dbName) { return openDB(dbName); } }, getSaveDetails: { value: getSaveDetails }, getAllSaves: { value: getAllSaves }, saveList: { value: saveList }, saveState: { value: saveState }, loadState: { value: loadState }, setItem: { value: setItem }, getItem: { value: getItem }, deleteItem: { value: deleteItem }, clearAll: { value: clearAll }, updateSettings: { value: updateSettings }, funNuke: { value: funNuke }, ekuNnuf: { value: ekuNnuf }, importFromLocalStorage: { value: importFromLocalStorage }, })); })(); window.idb = idb; /** * hotkeys support for links and buttons */ const Links = (() => { "use strict"; let currentLinks = []; let numberPrepend = "("; let numberAppend = ") "; let enabled = true; let disableNumbers = false; let disableRNGReload = false; let keyNumberMatcher; let maxKeyDescLength; let throttle = false; let skipElements = ".no-numberify, .no-numberify *"; let includeElements = ""; function keyNumberMatcherUpdate() { keyNumberMatcher = new RegExp(RegExp.escape(numberPrepend) + "((Ctrl|Alt|Shift) \\+ )?\\d" + RegExp.escape(numberAppend)); maxKeyDescLength = numberAppend.length + numberPrepend.length + 9; } keyNumberMatcherUpdate(); function getPrettyKeyNumber(counter) { let str = ""; switch (Math.floor((counter - 1) / 10)) { case 3: str = "Alt + "; break; case 2: str = "Ctrl + "; break; case 1: str = "Shift + "; break; } str += (counter % 10).toString(); return str; } function generateLinkNumbers(content, visibility) { if (!enabled || disableNumbers || V.options && !V.options.numberify_enabled) return; const stamp = performance.now(); if (throttle + 100 > stamp) { throttle = stamp; generateDebounce(); return; } throttle = stamp; if (visibility) { currentLinks = $(content).find(".link-internal").not(":hidden"); } else { currentLinks = $(content).find(".link-internal").filter((i, link) => getComputedStyle(link).display !== "none"); } if (skipElements && includeElements) { const goodies = $(content).find(includeElements); const baddies = $(content).find(skipElements).not(goodies); currentLinks = currentLinks.not(baddies); } else if (skipElements) { const baddies = $(content).find(skipElements); currentLinks = currentLinks.not(baddies); } for (let i = 0; i < currentLinks.length; i++) { const el = currentLinks[i]; if (i === 40) { if (enabled === "debug") console.log("Links: there's too many! found", currentLinks.length, "matches, exiting after the 40th one.\n time spent: ", performance.now() - stamp) return; } const keyNumber = numberPrepend + getPrettyKeyNumber(i + 1) + numberAppend; if (keyNumberMatcher.test(el.innerHTML.slice(0, maxKeyDescLength))) { el.innerHTML = el.innerHTML.replace(keyNumberMatcher, keyNumber); } else { el.prepend(keyNumber); } } if (enabled === "debug") console.log("Links: generated", currentLinks.length, "links, took", performance.now() - stamp, "ms"); } function generate() { return generateLinkNumbers(document.getElementsByClassName("passage")[0] || document, true); } const generateDebounce = $.debounce(200, generate); function linkFollow(index) { if (disableNumbers) return; if ($(currentLinks).length >= index) $(currentLinks[index - 1].click()); } function inputFocused() { if (["INPUT", "TEXTAREA"].includes(document.activeElement.tagName) && !["radio", "button", "checkbox", "submit", "reset", "image"].includes(document.activeElement.type)) return true; return false; } function init() { $(document).on(":passagerender", ev => { currentLinks = []; throttle = 0; generateLinkNumbers(ev.content); }); $(document).on("keydown", ev => { if (inputFocused()) return; if (ev.code.startsWith("Numpad")) ev.preventDefault(); }); $(document).on("keyup", ev => { if (!enabled || V.tempDisable || V.options && !V.options.numberify_enabled || inputFocused()) return; if (Dialog.isOpen()) return ev.code === "Escape" ? Dialog.close() : false; let offset = 0; if (ev.shiftKey) offset = 10; else if (ev.code.startsWith("Numpad") && ev.keyCode < 90) offset = 10; else if (ev.ctrlKey) offset = 20; else if (ev.altKey) offset = 30; switch (ev.code) { case "Digit1": case "Numpad1": case "KeyN": linkFollow(offset + 1); break; case "Digit2": case "Numpad2": linkFollow(offset + 2); break; case "Digit3": case "Numpad3": linkFollow(offset + 3); break; case "Digit4": case "Numpad4": linkFollow(offset + 4); break; case "Digit5": case "Numpad5": linkFollow(offset + 5); break; case "Digit6": case "Numpad6": linkFollow(offset + 6); break; case "Digit7": case "Numpad7": linkFollow(offset + 7); break; case "Digit8": case "Numpad8": linkFollow(offset + 8); break; case "Digit9": case "Numpad9": linkFollow(offset + 9); break; case "Digit0": case "Numpad0": linkFollow(offset + 10); break; case "NumpadDivide": if (ev.shiftKey) Engine.go(-2); else Engine.backward(); break; case "NumpadMultiply": if (disableRNGReload) break; State.restore(true); if (State.prng.isEnabled()) { State.random(); const frame = State.history[State.activeIndex]; frame.pull = State.prng.pull; } Engine.show(); break; case "NumpadSubtract": if (ev.shiftKey) Engine.go(2); else Engine.forward(); break; } }); } return Object.freeze(Object.defineProperties({}, { init: { value: init }, generate: { value: generate }, generateLinkNumbers: { value: generateLinkNumbers }, pushTheButton: { value: linkFollow }, numberPrepend: { get() { return numberPrepend; }, set(val) { numberPrepend = val; keyNumberMatcherUpdate(); } }, numberAppend: { get() { return numberAppend; }, set(val) { numberAppend = val; keyNumberMatcherUpdate(); } }, skipElements: { get() { return skipElements; }, set(val) { skipElements = val; } }, includeElements: { get() { return includeElements; }, set(val) { includeElements = val; } }, enabled: { get() { return enabled; }, set(val) { enabled = val; } }, disableRNGReload: { get() { return disableRNGReload; }, set(val) { disableRNGReload = val; } }, disableNumbers: { get() { return disableNumbers; }, set(val) { disableNumbers = val; } }, throttle: { get() { return throttle; }, set(val) { throttle = val; } }, currentLinks: { get() { return currentLinks; } }, })); })(); window.Links = Links; /*********************************************************************************************************************** sugarcube.js Copyright © 2013–2021 Thomas Michael Edwards <thomasmedwards@gmail.com>. All rights reserved. Use of this source code is governed by a BSD 2-clause "Simplified" License, which may be found in the LICENSE file. ***********************************************************************************************************************/ /* global Alert, Browser, Config, Dialog, Engine, Fullscreen, Has, LoadScreen, SimpleStore, L10n, Macro, Passage, Save, Scripting, Setting, SimpleAudio, State, Story, UI, UIBar, DebugBar, Util, Visibility, Wikifier , Links, idb */ /* Version object. */ var version = Object.freeze({ title : 'SugarCube', major : 2, minor : 36, patch : 1, prerelease : null, build : 1, date : new Date("2025-04-01T12:36:20.771Z"), extensions : {}, toString() { 'use strict'; const prerelease = this.prerelease ? `-${this.prerelease}` : ''; return `${this.major}.${this.minor}.${this.patch}${prerelease}+${this.build}`; }, short() { 'use strict'; const prerelease = this.prerelease ? `-${this.prerelease}` : ''; return `${this.title} (v${this.major}.${this.minor}.${this.patch}${prerelease})`; }, long() { 'use strict'; return `${this.title} v${this.toString()} (${this.date.toUTCString()})`; } }); /* Internal variables. */ var TempState = {}; var macros = {}; var postdisplay = {}; var postrender = {}; var predisplay = {}; var prehistory = {}; var prerender = {}; var session = null; var settings = {}; var setup = {}; var storage = null; /* Legacy aliases. */ var browser = Browser; var config = Config; var has = Has; var History = State; var state = State; var tale = Story; var TempVariables = State.temporary; /* Global `SugarCube` object. Allows scripts to detect if they're running in SugarCube by testing for the object (e.g. `"SugarCube" in window`) and contains exported identifiers for debugging purposes. */ window.SugarCube = {}; /* Main function, entry point for the story. */ jQuery(() => { 'use strict'; const mainStart = () => { if (DEBUG) { console.log('[SugarCube/main()] Document loaded; beginning startup.'); } /* WARNING! The ordering of the code within this function is critically important, so be careful when mucking around with it. */ try { const lockId = LoadScreen.lock(); LoadScreen.init(); if (document.normalize) { document.normalize(); } const initProcess = () => { console.log('initProcess()'); Story.load(); storage = SimpleStore.create(Story.domId, true); session = SimpleStore.create(Story.domId, false); Dialog.init(); UIBar.init(); Engine.init(); Story.init(); L10n.init(); if (!session.has('rcWarn') && storage.name === 'cookie') { session.set('rcWarn', 1); window.alert(L10n.get('warningNoWebStorage')); } Save.init(); Setting.init(); idb.init(Story.domId); Links.init(); Macro.init(); Engine.start(); if (Config.debug) { DebugBar.init(); } const $window = $(window); const vprCheckId = setInterval(() => { if (!$window.width()) { return; } clearInterval(vprCheckId); UIBar.start(); if (Config.debug) { DebugBar.start(); } jQuery.event.trigger({ type : ':storyready' }); setTimeout(() => LoadScreen.unlock(lockId), Engine.minDomActionDelay * 2); }, Engine.minDomActionDelay); Object.defineProperty(window, 'SugarCube', { value : Object.seal(Object.assign(Object.create(null), { Browser, Config, Dialog, Engine, Fullscreen, Has, L10n, Macro, Passage, Save, Scripting, Setting, SimpleAudio, State, Story, UI, UIBar, DebugBar, Util, Visibility, Wikifier, session, settings, setup, storage, version })) }); if (DEBUG) { console.log('[SugarCube/main()] Startup complete; story ready.'); } }; if (typeof i18nManager !== 'undefined') { i18nManager.loadTranslateData(['ValueZip', 'Remote']); i18nManager.isInited.then(() => { initProcess(); }); } else { initProcess(); } } catch (ex) { console.error(ex); LoadScreen.clear(); return Alert.fatal(null, ex.message, ex); } }; if (typeof window.modSC2DataManager !== 'undefined') { window.modSC2DataManager.startInit() .then(() => window.jsPreloader.startLoad()) .then(() => mainStart()) .catch(err => { console.error(err); }); } else { mainStart(); } }); /*********************************************************************************************************************** chs.js – 简体中文 Localization by: Liyro Pen. Copyright © 2017 Thomas Michael Edwards <thomasmedwards@gmail.com>. All rights reserved. Use of this source code is governed by a BSD 2-clause "Simplified" License, which may be found in the LICENSE file. For more information about the guidelines used to create this localization, see: http: ***********************************************************************************************************************/ (function () { if (!navigator.language.startsWith('zh')) { return; } l10nStrings.identity = '游戏'; l10nStrings.aborting = '终止'; l10nStrings.cancel = '取消'; l10nStrings.close = '关闭'; l10nStrings.ok = '确认'; l10nStrings.errorTitle = '错误'; l10nStrings.errorNonexistentPassage = '段落"{passage}"不存在'; l10nStrings.errorSaveMissingData = '存档缺少必须的数据，可能被读取的文件不是存档或者存档被损坏'; l10nStrings.errorSaveIdMismatch = '保存{identity}是错误的'; l10nStrings._warningIntroLacking = '你的浏览器可能损坏或者被禁用'; l10nStrings._warningOutroDegraded = '，所以{identity}在受限制模式中运行。你可以继续运行，但是一些内容可能不能正确工作。'; l10nStrings.warningNoWebStorage = '{_warningIntroLacking} Web Storage API {_warningOutroDegraded}'; l10nStrings.warningDegraded = '{_warningIntroLacking} {identity}需要的功能 {_warningOutroDegraded}'; l10nStrings.debugViewTitle = '调试模式'; l10nStrings.debugViewToggle = '切换调试模式'; l10nStrings.debugBarToggle = '切换调试栏'; l10nStrings.debugBarNoWatches = '\u2014 尚无监控组 \u2014'; l10nStrings.debugBarAddWatch = '添加监控'; l10nStrings.debugBarDeleteWatch = '删除监控'; l10nStrings.debugBarWatchAll = '监控全部'; l10nStrings.debugBarWatchNone = '删除全部'; l10nStrings.debugBarLabelAdd = '添加'; l10nStrings.debugBarLabelWatch = '监控'; l10nStrings.debugBarLabelTurn = '调整'; l10nStrings.debugBarLabelViews = '视图'; l10nStrings.debugBarViewsToggle = '切换调试视图'; l10nStrings.debugBarWatchToggle = '切换监控面板'; l10nStrings.uiBarToggle = '打开/关闭导航栏'; l10nStrings.uiBarBackward = '后退'; l10nStrings.uiBarForward = '前进'; l10nStrings.uiBarJumpto = '跳到{identity}的历史记录中的某一点'; l10nStrings.jumptoTitle = '跳到'; l10nStrings.jumptoTurn = '转到'; l10nStrings.jumptoUnavailable = '目前没有跳跃点\u2026'; l10nStrings.savesTitle = '存档'; l10nStrings.savesDisallowed = '在这个段落中不允许存档'; l10nStrings.savesEmptySlot = '\u2014 插槽空 \u2014'; l10nStrings.savesIncapable = '{_warningIntroLacking}支持存档所需的功能，因此本次游戏的存档功能已被禁用'; l10nStrings.savesLabelAuto = '自动存档'; l10nStrings.savesLabelDelete = '删除'; l10nStrings.savesLabelExport = '另存为\u2026'; l10nStrings.savesLabelImport = '读取\u2026'; l10nStrings.savesLabelLoad = '读取'; l10nStrings.savesLabelClear = '全部删除'; l10nStrings.savesLabelSave = '保存'; l10nStrings.savesLabelSlot = '插槽'; l10nStrings.savesSavedOn = '保存在：'; l10nStrings.savesUnavailable = '未找到存档插槽\u2026'; l10nStrings.savesUnknownDate = '未知'; /* idb related */ l10nStrings.savesDisallowedReplay = '目前正在使用场景查看器，无法正常保存。'; l10nStrings.savesExportReminder = '警告：如果你清除了浏览器缓存，此处的存档也将丢失！请定时导出存档！'; l10nStrings.savesHeaderSaveLoad = '保存/加载'; l10nStrings.savesHeaderIDName = 'ID/名称'; l10nStrings.savesHeaderDetails = '描述'; l10nStrings.savesDescTitle = '标题：'; l10nStrings.savesDescName = '存档名：'; l10nStrings.savesDescId = '存档 ID：'; l10nStrings.savesDescDate = '日期：'; l10nStrings.savesPagerJump = '跳转到最近一次手动保存'; l10nStrings.savesPagerPage = '页数：'; l10nStrings.savesPagerSavesPerPage = '每页存档个数：'; l10nStrings.savesOptionsConfirmOn = '保存时需要确认'; l10nStrings.savesOptionsOverwrite = '覆盖'; l10nStrings.savesOptionsUseLegacy = '使用旧版储存方式'; l10nStrings.savesWarningSaveOnSlot = '保存存档到槽 '; l10nStrings.savesWarningOverwriteSlot = '覆盖存档到槽 '; l10nStrings.savesWarningOverwriteID = '存档 ID 不匹配，是否继续覆盖？'; l10nStrings.savesWarningDeleteInSlot = '删除存档槽：'; l10nStrings.savesWarningLoad = '加载存档槽：'; l10nStrings.savesWarningDeleteAll = '警告：你确定要删除所有存档吗？'; l10nStrings.savesLabelToClipboard = '保存至剪贴板\u2026'; l10nStrings.settingsTitle = '设置'; l10nStrings.settingsOff = '关闭'; l10nStrings.settingsOn = '开启'; l10nStrings.settingsReset = '重置为默认值'; l10nStrings.restartTitle = '重新开始'; l10nStrings.restartPrompt = '你确定要重新开始吗？未保存的进度将会丢失。'; l10nStrings.shareTitle = '分享'; /* Alert. */ l10nStrings.alertTitle = '警告'; l10nStrings.autoloadTitle = '自动保存'; l10nStrings.autoloadCancel = '前往最初的段落'; l10nStrings.autoloadOk = '读取自动存档'; l10nStrings.autoloadPrompt = '有一个自动存档，读取它还是前往最初的段落？'; l10nStrings.macroBackText = '返回'; l10nStrings.macroReturnText = '返回'; })(); })(window, window.document, jQuery); } </script> </body> </html> 